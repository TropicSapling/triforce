/// ==================================================================================
/// 
///                     ########  TRIFORCE SPECIFICATION  ########
/// 
/// ==================================================================================

/// # Triforce by Example
/// This file specifies the Triforce language by means of code examples.
/// 
/// **Note:**
/// - Only non-obvious parts of the language are explained here.
/// - The specification is incomplete and ever-evolving.


/// ##################################################################################
/// ##################################################################################


/// ================
/// ## Formal syntax
/// ================
/// 
/// The formal syntax will be specified with a metalanguage similar to Go's:
/// ```
/// Syntax     = [Definition]…
/// Definition = def_name "=" Expression ["\n" "|" Expression]… "\n"
/// Expression = Term ["|" Term]…
/// Term       = Factor [Factor]…
/// Factor     = def_name | tok["-"tok] | Group | Option
/// Group      = "("Expression")"
/// Option     = "["Expression"]"["…"]
/// ```
/// 
/// Lexical tokens are enclosed in "" or `` (i.e. "let", "=", "``" or `""`).
/// Terminal tokens are lowercase. Non-terminal tokens are CamelCase.
/// - `[a-b]` = characters a through b
/// 
/// Note that one or more consecutive newlines - potentially intertwined with any
/// other whitespace, which is ignored - together form a `\n` token. All other
/// whitespace is ignored, apart from serving to separate non-newline tokens.
/// 
/// ### General
/// -----------
/// ```
/// Syntax     = [Expression]
/// Expression = CmdCall|FuncUse|block
/// 
/// CmdCall = (BlockDef|GroupDef|TokenDef|Lambda) [Expression]
/// FuncUse = (IdentToken|Argument) [IdentToken|Argument]…
/// ```
/// 
/// Note that `FuncUse` must always contain *at least* one `IdentToken`.
/// 
/// ### Block Definitions
/// ---------------------
/// ```
/// BlockDef = "defblock" BVariant BStart BEnd BEsc
/// BVariant = "comment"|"string"|"cstring"|"custom"
/// BStart   = regex_with_var_def_and_interpolation
/// BEnd     = regex_with_var_def_and_interpolation
/// BEsc     = regex_with_var_def_and_interpolation | "(" ")"
/// ```
/// 
/// ### Group/Token Definitions
/// ---------------------------
/// ```
/// GroupDef = "defgroup"  "(" [token]… ")"
/// TokenDef = "deftokens" "(" [token]… ")"
/// ```
/// 
/// ### λλλλλ
/// ---------
/// ```
/// Lambda    = "λ" ("transform"|"function") ParamList FuncBody [ArgList]
/// ParamList = "(" [Parameter]… ")"
/// FuncBody  = "(" [Expression] ")"
/// ArgList   = "(" [Argument]…  ")"
/// 
/// Parameter = "(" ParName [Type] ")" | "'" Type "'"
/// ParName   = "(" [AttrList] FuncPart [FuncPart]… ")" | IdentToken
/// FuncPart  = Parameter|IdentToken
/// 
/// Argument = Expression | Builtin | "$" [IdentToken]
/// ```
/// 
/// ### Type System
/// ---------------
/// ```
/// Type = "(" [Type] ")"
///      | "<" [Type] ">"
///      | TypeOp
/// 	 | MatPat
///      | Single
/// 
/// TypeOp = [Type] "&" [Type]
///        | [Type] "|" [Type]
///        |        "~" [Type]
/// 
/// MatPat = ("#" Parameter | IdentToken) ["#" Parameter | IdentToken]…
/// Single = Builtin|block
/// ```
/// 
/// ### Attributes
/// --------------
/// ```
/// AttrList  = "##" "(" [Attribute]… ")"
/// Attribute = "(" (PreceAttr|AssocAttr) ")"
/// 
/// PreceAttr = Builtin "precedes" Builtin
/// AssocAttr = "assoc" ("none"|"left"|"right")
/// ```
/// 
/// Precedence relations form a DAG - see figure 1 in the following paper:
/// [https://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf]
/// 
/// Default associativity should probably be "none" or "left".
/// 
/// ### Foreign Function Interface
/// ------------------------------
/// ```
/// RunForeign = "runforeign" "rust" block
/// ```
/// 
/// ### Misc.
/// ---------
/// ```
/// Builtin    = "this"|"..."|"_"
/// IdentToken = token
/// ```
/// 
/// Comments and whitespace can be inserted anywhere.
/// Note however that newlines count as tokens and are sometimes used.

/// -----------------------------------

// Below is some sort of prelude/foundation to test the syntax

defblock comment //        \n    ()
defblock string  "         "     \\
defblock cstring `         `     \\
defblock cstring \(x=)===+ \(x)  ()

/// Groups and blocks are used for deciding how to form tokens.
/// - Comment blocks and whitespace groups are ignored and do not form tokens.
/// - Remaining blocks & groups form tokens as has been defined.
defgroup (+ - * / ^ < > & | =)
defgroup (@ % ? !)
defgroup (. ,)
defgroup (: ;)
defgroup ($ #)
/// Built-in groups:
/// - Default
/// - Whitespace, excl. `\n`
/// - `\n`

/// The `deftokens` command defines specific stand-alone tokens.
deftokens ({ } [ ] ~ ')
/// Built-in tokens:
/// - `(`
/// - `)`

/// Example following the above definitions:
/// > let invalidstr str="123 + 456"//+789
/// > 				   *=(("*789"))
/// =>
/// [let, invalidstr, str, =, "123 + 456", *=, (, (, "*789", ), ), \n]

λ transform () (
	==================================================================================
	λ function (((##((_ precedes this)) let (pat `\(_)`) = (val)\\n(scope `\(_)`)))) (
		\(glob_scope)
	) (
		λ transform ((pat) (val) (scope)) (
			========================================
			λ function (\\(pat)) \\(scope) (\\(val))
			========================================
		) ($pat $val $scope) // `$` = unapplied arg
	)
	==================================================================================
) ()

/// Everything here and after is passed as the final input to `λ`.
/// Every `CmdCall` takes what follows it as its final input.
/// 
/// Meaning that, for example:
/// > defgroup (@ % ? !)
/// > defgroup ,
/// > defgroup .
/// > ...
/// <=>
/// > defgroup (@ % ? !) (
/// >	 defgroup , (
/// >		 defgroup . (
/// >			 ...
/// >		 )
/// >	 )
/// > )

let ({(expr)}) = λ function ((expr)) (expr) // unapplied `$expr` is implicit

let (println (x)\n(scope `\(_)`)) = λ transform ((x)) (
	======================================
	runforeign rust `println("{}", \(x));`

	\(scope)
	======================================
)

println "hello, world"


/// ##################################################################################


/// ==============
/// ## Type system
/// ==============
/// 
/// `_` = the set of all types
/// 
/// The type system is loosely based on set theory. It follows similar rules, but has
/// a different syntax specially crafted for programming. A type is defined as a set
/// of zero, one or more values, where the values may be types themselves.

/// ### Examples
/// ------------

// The empty, uninhabited bottom type is an empty set without values.
let N/A: type = |;
// It is the complement of the universal top type, which contains all values:
let any: type = _;

~any :== ~_ :== N/A;

// Since the empty `N/A` type matches nothing, this "function" cannot be called.
func Object ($field as any) (N/A);
// Instead, we can partially apply it to use it as an object:
let obj = Object "field value";

// The singleton type is a set of one value.
let mut typ = "singleton";
// Values can be added to a type using the `|` ("or") operator.
typ |= 1|2|3;
// As well as filtered using the `&` ("and") operator.
typ &= 2|"singleton";

typ :== "singleton"|2;

// Best to remove mutability when no longer needed
let typ = typ;

// TODO ... [to fully solve: see "N/A - the type with no value" in random_experiments]

// TODO more:
// - type equality, should order matter or not?
// - maybe have `super` keyword for when superposition types should be allowed?
// - subset checking by default, or checking just if in set by default?


/// ##################################################################################


/// =================
/// ## Type inference
/// =================
/// 
/// `...` = the set of all allowed values in the context it is used
/// 
/// This special pseudo-type is useful for scripting/prototyping, as it is a
/// shapeshifter and takes on the form of whatever type is applicable in the context
/// it is used. Using it allows you to code in a more dynamic way, removing the need
/// to think about what types variables and functions should have. It is not strictly
/// dynamic typing as `...` is still technically meant to be statically inferred,
/// but many of the cons of dynamic typing still apply. Consequently, using `...` in
/// this way should be left for code where correctness is not of importance.
/// 
/// Another use of the type is to solve equations. `...` can be seen as the unknown
/// in an equation, and be given a name like `let x = ...`. The compiler will then
/// figure out one or more values that the unknown variable can take on.

/// ### Syntax sugar
/// ----------------

func f $x;
// <=>
func f ($x as ...);
// <=>
func f ($x as ...) --> ...;

/// ### Examples
/// ------------

func f ($x as ...) --> ... {x + 123}
// <=>
func f ($x as num) --> any {x + 123}

let a: ... = 456;
// <=>
let a: ___ = 456; // note: `___` = `_` = `any`

println (f a);         // OK
//> println (f "str"); // type error

////////////////

let n: int = ...;

2*n + 1 :== 9; // <=> `(2*n + 1 == 9): True`
2*n     :== 8;
  n     :== 4; // "n should equal 4"

println n; //> 4


/// ##################################################################################


/// =============
/// ## Evaluation
/// =============
/// 
/// By default, every pure (non-I/O, non-effectual, deterministic) expression
/// that *can* be evaluated at compile time, *will* be evaluated at compile time.
/// - Evaluation timing out during compilation will finish during runtime.
/// 
/// `run $expr` overrides the default and forces *runtime* execution of `$expr`.
/// 
/// `prerun $expr` forces *compile time* execution of any (impure) expression.

/// ### Examples
/// ------------

{
	func f $x {x + 123}

	let a = 456;

	println (f a);
	prerun println "f(a) = ${f a}";
	
	run {
		let b = 321;
		println(f b);
	}
}
// <=> (after compile time evaluation)
{
	func f $x {x + 123}
	
	println 579;
	
	let b = 321;
	println(f b);
}
// Additionally, "f(a) = 579" will be printed during compilation.
