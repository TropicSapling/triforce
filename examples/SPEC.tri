/// ==================================================================================
/// 
///                     ########  TRIFORCE SPECIFICATION  ########
/// 
/// ==================================================================================

/// # Triforce by Example
/// This file specifies the Triforce language by means of code examples.
/// 
/// **Note:**
/// - Only non-obvious parts of the language are explained here.
/// - The specification is incomplete and ever-evolving.


/// ##################################################################################
/// ##################################################################################


/// ================
/// ## Formal syntax
/// ================
/// 
/// The formal syntax will be specified with a metalanguage similar to Go's:
/// ```
/// Syntax     = [Definition]…
/// Definition = def_name "=" Expression ["\n" "|" Expression]… "\n"
/// Expression = Term ["|" Term]…
/// Term       = Factor [Factor]…
/// Factor     = def_name | tok["-"tok] | Group | Option
/// Group      = "("Expression")"
/// Option     = "["Expression"]"["…"]
/// ```
/// 
/// Lexical tokens are enclosed in "" or `` (i.e. "let", "=", "``" or `""`).
/// Terminal tokens are lowercase. Non-terminal tokens are CamelCase.
/// - `[a-b]` = characters a through b
/// 
/// Note that one or more consecutive newlines - potentially intertwined with any
/// other whitespace, which is ignored - together form a `\n` token. All other
/// whitespace is ignored, apart from serving to separate non-newline tokens.
/// 
/// ### General
/// -----------
/// ```
/// Syntax = Expr
/// Expr   = List|Atom
/// Atom   = ident_atom|literal|"..."
/// ```
/// 
/// Every program consists of a single `Expr` containing its code. This expression is
/// either a (typically nested) `List` or an `Atom`. If the file contains multiple
/// atoms, these will automatically become enclosed by parentheses so that they form
/// a single `List` (of type `CodeAsList`; see section on Lists for further details).
/// 
/// Additionally, within any `List` more parentheses will be automatically inserted as
/// specified by precedence rules, ultimately forming more `CodeAsList`s. This means
/// that parentheses can in many cases be omitted.
/// 
/// **Note:** An `ident_atom` is allowed to be the special `\n` token described above.
/// 
/// ### Lists
/// ---------
/// ```
/// List = CodeAsList
///      | CStrAsList
/// 
/// CodeAsList = BegCode [CodeItems] EndCode
/// CStrAsList = BegCStr [CodeItems] EndCStr
/// 
/// CodeItems = CodeItem [CodeItem]…
/// CodeItem  = Expr
/// 
/// CodeItems = (List|ident_atom) [Argument]…
///           | LambdaObject
///           | Command
///           | Mixfix
///           | Atom
/// 
/// BegCode = "("|"(>>>"
/// EndCode = ")"
/// BegCStr = user_defined
/// EndCStr = user_defined
/// ```
/// 
/// `CodeAsList` is a list of code items which are all evaluated together as a whole.
/// `CStrAsList` is identical apart from only evaluating escaped `"\\"CodeAsList`s.
/// 
/// **NOTE:**
/// The special open-ended parenthesis `(>>>` implicitly places a closing `EndCode`
/// at the end of the scope. That is, it automatically inserts a new `)` right before
/// an already existing scope-ending `)`. If no such scope-ender is found, the scope
/// continues until the EOF or potentially past it if the file is included elsewhere.
/// 
/// ### Mixfix
/// ----------
/// ```
/// Mixfix = (Argument|ident_atom) [Argument|ident_atom]…
/// 
/// Argument = Expr | "$"[ident_atom]
/// ```
/// 
/// Note that `Mixfix` must always contain *at least* one `ident_atom`.
/// 
/// ### SPECIAL FORMS
/// -----------------
/// Special forms are evaluated differently from normal expressions.
/// 
/// λλλλλλλ
/// -------
/// ```
/// LambdaObject = "Function"|"Transform" ParamList Expr
/// 
/// ParamList = BegCode [Parameter]…   EndCode
/// Parameter = BegCode ParName [Type] EndCode
///           | "'" Type "'"
/// 
/// ParName = BegCode [Attr] (Parameter|ident_atom) [Parameter|ident_atom]… EndCode
///         | ident_atom
/// ```
/// 
/// **Evaluation:**
/// - First code item follows normal evaluation, but must evaluate to a valid keyword.
/// - `ParamList` defines parameters; only `Type`s are evaluated normally.
/// - `Expr` evaluates to a reduced form of itself serving as the function body.
/// 
/// **NOTE:**
/// `(>>>` as part of `Parameter` here indicates something slightly different than it
/// normally does. It will not enclose everything that follows it, but instead act as
/// a normal start-of-parameter - apart from also declaring that an open-ended `(>>>`
/// should be automatically placed ahead of the parameter/argument at application.
/// 
/// Commands
/// --------
/// ```
/// Command = BlockDef
///         | GroupDef
///         | TokenDef
///         | RunForeign
/// ```
/// 
/// **Evaluation:**
/// - First code item follows normal evaluation, but must evaluate to a valid keyword.
/// - Evaluation of remaining code items depend on the command.
/// 
/// Block Definitions
/// -----------------
/// ```
/// BlockDef = "defblock" BVariant BStart BEnd BEsc Expr
/// BStart   = regex_with_var_def_and_interpolation
/// BEnd     = regex_with_var_def_and_interpolation
/// BEsc     = regex_with_var_def_and_interpolation | "(" ")"
/// 
/// BVariant = "comment"|"string"|"cstring"|"custom"
/// ```
/// 
/// **Evaluation:**
/// - `BVariant` follows normal evaluation, but must evaluate to a valid keyword.
/// - Regex terms evaluate to themselves.
/// - `Expr` is evaluated normally.
/// 
/// Group/Token Definitions
/// -----------------------
/// ```
/// GroupDef = "defgroup"  "(" [token]… ")" Expr
/// TokenDef = "deftokens" "(" [token]… ")" Expr
/// ```
/// 
/// **Evaluation:**
/// - Tokens evaluate to themselves.
/// - `Expr` is evaluated normally.
/// 
/// Foreign Function Interface
/// --------------------------
/// ```
/// RunForeign = "runforeign" "rust" block
/// ```
/// 
/// **Evaluation:**
/// - Second code item follows normal evaluation, but must evaluate to `rust`.
/// - The code block at the end is evaluated as Rust code.
/// 
/// ### Type System
/// ---------------
/// ```
/// Type = "(" [Type] ")"
///      | "<" [Type] ">"
///      | UnaTypeOp
///      | BinTypeOp
///      | MatPat
///      | Single
/// 
/// UnaTypeOp = "super" [Type]
///           | "power" [Type]
///           | "~"     [Type]
/// 
/// BinTypeOp = [Type] "&" [Type]
///           | [Type] "|" [Type]
/// 
/// MatPat = (Match|token) [Match|token]…
/// Single = Builtin|block
/// 
/// Match = "$"[ident_atom] | "#"[Parameter]
/// ```
/// 
/// ### Attributes
/// --------------
/// ```
/// AttrList  = "##" "(" [Attribute]… ")"
/// Attribute = "(" (PreceAttr|AssocAttr) ")"
/// 
/// PreceAttr = Builtin "precedes" Builtin
/// AssocAttr = "assoc" ("none"|"left"|"right")
/// ```
/// 
/// Precedence relations form a DAG - see figure 1 in the following paper:
/// [https://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf]
/// 
/// Default associativity should probably be "none" or "left".
/// 
/// ### Misc.
/// ---------
/// ```
/// ReservedIdentAtom = "Function"
///                   | "Transform"
///                   | "defblock"
///                   | "defgroup"
///                   | "deftokens"
///                   | "runforeign"
/// ```
/// 
/// Comments and whitespace can be inserted anywhere.
/// Note however that newlines count as tokens and are sometimes used.

/// -----------------------------------

// Below is some sort of prelude/foundation to test the syntax

defblock comment //        \n    () (>>>
defblock string  \(x=)"""+ \(x)  () (>>> //"
defblock string  "         "     \\ (>>>
defblock cstring `         `     \\ (>>>
defblock cstring \(x=)===+ \(x)  () (>>>

/// Groups and blocks are used for deciding how to form tokens.
/// - Comment blocks and whitespace groups are ignored and do not form tokens.
/// - Remaining blocks & groups form tokens as has been defined.
defgroup (+ - * / ^ < > & | =) (>>>
defgroup (@ % ? !)             (>>>
defgroup (. ,)                 (>>>
defgroup (: ;)                 (>>>
defgroup ($ #)                 (>>>
/// Built-in groups:
/// - Default
/// - Whitespace, excl. `\n`
/// - `\n`

/// The `deftokens` command defines specific stand-alone tokens.
deftokens ({ } [ ] ~ ') (>>>
/// Built-in tokens:
/// - `(`
/// - `)`
/// - `(>>>`

/// Example following the above definitions:
/// > let invalidstr str="123 + 456"//+789
/// > 				   *=(("*789"))
/// =>
/// [let, invalidstr, str, =, "123 + 456", *=, (, (, "*789", ), ), \n]

/// Functions/Transforms are special built-in objects with 2 fields: parameters, body.
/// The fields are evaluated in order, but since they are not normal expressions they
/// are evaluated in special ways specific to each field. They both evaluate to
/// reduced forms where as much as possible has been evaluated normally.
/// - Whatever cannot be normally evaluated will evaluate to itself
(Transform [(glob_scope)] (
	================================================
	(Function [((let (pat) = (val)\\n(>>>scope)))] (
		\(glob_scope)
	)) (Transform [(pat), (val), (scope)] (
		========================================
		(Function [\\(pat)] (\\(scope))) \\(val)
		========================================
	))
	================================================
))) (>>>(>>>

/// Everything here and after is passed as input to the `Transform`.
/// This is because `(>>>` is a special, open-ended parenthesis.
/// 
/// Meaning that:
/// > (Transform [(glob_scope)] (...)) (>>>(>>>
/// > ...
/// <=>
/// > (Transform [(glob_scope)] (...)) ((
/// >	 ...
/// > ))
/// 
/// That is, the global scope is passed as the `glob_scope` argument.

let (N/A) = |
let _     = ~N/A
let any   = _

let type1 = 123
let type2 = 1|2|3

/// Example Function ...
let lambda = Function [(x type1), (y type2), (z)] (
	runforeign rust `println("Got {}, {}, {}.", \(x), \(y), \(z));` (

	Transform [((function taking (a) and (b type2)))] (
		runforeign rust `println("Entered macro.");` (

		=================================================
		\(function taking $ and 2) // partial application
		=================================================
	)))
)
/// ... and then again, with the RHS evaluated into a final *object value*:
let lambda = Function ['123', (y 1|2|3), (z _)] (
	runforeign rust `println("Got {}, {}, {}.", 123, \(y), \(z));` (

	Transform [(
		(function taking '|' and '1|2|3')
		Function|Transform [#'_', (#'_' #'super 1|2|3')] #'_'
	)] (
		runforeign rust `println("Entered macro.");` (

		=================================================
		\(function taking $ and 2) // partial application
		=================================================
	)))
)
/// TODO: **Come up with a binary representation for the final object values.**
/// We want every program to reduce to one final object value compiling into a binary
/// representation of it that also acts as the program's real, executable binary code.
/// 
/// Final object value = normal form
/// 
/// TODO: figure out how equality of functions should be decided

let ({(expr)}) = (λ function ((expr)) (expr)) $expr // `$` = unapplied arg

let (println (x)\n(>>>scope)) = λ transform ((x)) (
	======================================
	runforeign rust `println("{}", \(x));`

	\(scope)
	======================================
)

println "hello, world"
// `(>>>` automatically inserted here, per the above function definition

// Testing pattern matching / type checking on λ below ...

let f = λ function ((x int) (y int) (z int)) (x + y + z)

// λ
let f λ _ _ _ = f
// λ function, 1+ parameters (defines first=`(x int)` rest=`(y int) (z int)` in scope)
let f λ function ¤(#(first) #(rest)) _ = f
// λ function, 3 parameters
let f λ function `\(_) \(_) \(_)` _ = f
// λ function, 3x `int` => `int`
let f λ function `\('int') \('int') \('int')` int = f


/// ##################################################################################


/// ==============
/// ## Type system
/// ==============
/// 
/// The type system is based on pattern matching and set theory.
/// Every parameter has a match position containing a pattern value to match input on.
/// If this position is left unspecified, its pattern value will default to `...`.
/// 
/// `Pattern = Value = Object|TypeSet|"..."`
/// 
/// - `Object`   = the basic value, optionally having fields
/// - `TypeSet`  = set of 0, 1 or more values
/// - `"..."`    = special value evaluating to a suitable pattern
/// 
/// ### TypeSet
/// -----------
/// A `TypeSet` is a set of 0, 1 or more values. It comes in 2 forms:
/// - The *inclusively matching* `TypeSet`
/// - The *excludingly matching* `TypeSet`
/// 
/// The first form is the default and will match any value contained in itself.
/// The second form is the inverse of the first and will instead match all values
/// *not* in the set. You can get the inverse set by using the complement/inverse
/// operator `~` on a normal set. The `~` operator also combines with itself and other
/// operators to enable switching back and forth between inverse and normal sets.
/// 
/// **NOTE:** These 2 variants are *necessary* in order to allow for important type
/// checking that would otherwise introduce paradoxes if implemented only with pure
/// sets. For example, the wildcard operator `_` cannot be a set, because then it
/// would have to contain itself. Therefore, `_` is instead defined as simply being
/// the excludingly matching empty set `~|`.

/// ### Examples
/// ------------

// The empty, uninhabited bottom type is an empty set without values.
let (N/A) type = |
// It is the complement of the universal top type (wildcard), which matches anything:
let  any  type = _ = ~|

~any :== ~_ :== ~~| :== N/A

// Since the empty `N/A` type matches nothing, this "function" cannot be called.
func Object (field any) (N/A);
// Instead, we can partially apply it to use it as an object:
let obj = Object "field value"

// The singleton type is a set of one value.
let mut typ = "singleton"
// Values can be added to a type using the `|` ("or") operator.
typ |= 1|2|3
// As well as filtered using the `&` ("and") operator.
typ &= 2|"singleton"

typ :== "singleton"|2

// Best to remove mutability when no longer needed
let typ = typ

// `N/A` matches no value, which means it technically matches the lack of a value.
// Hence, any non-returning function will have its return type being `N/A`.
partial func f() --> N/A { f()   }
partial func g() --> N/A { panic }

// This also makes it possible to check for totality:
func total() --> ... where (this is N/A) is False {
	...
}
// Note though that this check is unnecessary for non-partial `func`:
// It already does such a totality check automatically.

// Instead of defining a new variable, the below simply type checks `"something"`
let 'str' = "something"
// <=>
let _ str = "something"

// Pattern matching on object field - and extracting into variable
let 'Cons (Cons #(field Cons int))' = Cons (Cons (Cons 123))

println field
//> Cons 123

// Patterns are first-class
let pattern <Cons (Cons #(field Cons int))> = Cons (Cons #(field Cons int))

// Type checking...
let var typ = val
// ... of objects
let obj 1|2|3 = 2
// ... of types
let typ <1|2|3> = 1|2|3
// ... of types of types
let typ_of_typ <<1|2|3>> = typ
// ... of types of types and objects
let complex_typ <<1|2|3>|1|2|3|4|5|6> = <typ>|typ|4|5|6

// TODO ... [to fully solve: see "N/A - the type with no value" in random_experiments]

// TODO more:
// - type equality, should order matter or not?
//       - Probably best to ignore order of elements. Order seemed helpful in some
//         cases, but those cases have (better?) workarounds + order causes issues.
// - maybe have `super` keyword for when superposition types should be allowed?
//       - UPDATE: better with `#'...'` for superposition types
// - subset + member checking combined by default, or member checking only by default?
//       - UPDATE: member checking better, `#'...'` superpos types resolves issue
// - **NOTE:** Subset checking means the empty set `|` matches itself.
//             Meaning there would be no way to fully block an argument application.
//             (Unless make special exception for the empty type of course)


/// ##################################################################################


/// =================
/// ## Type inference
/// =================
/// 
/// `...` = the set of all allowed values in the context it is used
/// 
/// This special pseudo-type is useful for scripting/prototyping, as it is a
/// shapeshifter and takes on the form of whatever type is applicable in the context
/// it is used. Using it allows you to code in a more dynamic way, removing the need
/// to think about what types variables and functions should have. It is not strictly
/// dynamic typing as `...` is still technically meant to be statically inferred,
/// but many of the cons of dynamic typing still apply. Consequently, using `...` in
/// this way should be left for code where correctness is not of importance.
/// 
/// Another use of the type is to solve equations. `...` can be seen as the unknown
/// in an equation, and be given a name like `let x = ...`. The compiler will then
/// figure out one or more values that the unknown variable can take on.

/// ### Syntax sugar
/// ----------------

func f $x;
// <=>
func f ($x as ...);
// <=>
func f ($x as ...) --> ...;

/// ### Examples
/// ------------

func f ($x as ...) --> ... {x + 123}
// <=>
func f ($x as num) --> any {x + 123}

let a: ... = 456;
// <=>
let a: ___ = 456; // note: `___` = `_` = `any`

println (f a);         // OK
//> println (f "str"); // type error

////////////////

let n: int = ...;

2*n + 1 :== 9; // <=> `(2*n + 1 == 9): True`
2*n     :== 8;
  n     :== 4; // "n should equal 4"

println n; //> 4


/// ##################################################################################


/// =============
/// ## Evaluation
/// =============
/// 
/// By default, every pure (non-I/O, non-effectual, deterministic) expression
/// that *can* be evaluated at compile time, *will* be evaluated at compile time.
/// - Evaluation timing out during compilation will finish during runtime.
/// 
/// `run $expr` overrides the default and forces *runtime* execution of `$expr`.
/// 
/// `prerun $expr` forces *compile time* execution of any (impure) expression.

/// ### Examples
/// ------------

{
	func f $x {x + 123}

	let a = 456;

	println (f a);
	prerun println "f(a) = ${f a}";
	
	run {
		let b = 321;
		println(f b);
	}
}
// <=> (after compile time evaluation)
{
	func f $x {x + 123}
	
	println 579;
	
	let b = 321;
	println(f b);
}
// Additionally, "f(a) = 579" will be printed during compilation.
