Zero = Nat Zero;
Suc = Nat Suc;

{
	n = Nat n;
	m = Nat m;
	
	Zero + (n) = n;
	(n) + Zero = n;
	Suc (n) + (m) = Suc (n + m);
	(n) + Suc (m) = Suc (n + m);
};

(a) += (b) = (a = a + b);

{
	True = Bool True;
	False = Bool False;
	
	!True = False;
	!False = True;
	
	(a) == (b) = True|False;
	(a) != (b) = !(a == b);
	
	False || False = False;
	False || True = True;
	True || False = True;
	True || True = True;
	
	False && False = False;
	False && True = False;
	True && False = False;
	True && True = True;
	
	if True (body) = body;
	if True (body) else (expr) = body;
	if False (body) = Void;
	if False (body) else (expr) = expr;
};

rand Nat (start) Nat (end) = Nat start|(Suc start)|...end = SYS_RAND;

println (n) = Void;

let n = Suc Zero; // same as 1
n += rand Zero (Suc Zero); // n = Suc (Zero|(Suc Zero)) which is the same as 1|2

(n = 2|3|...) backwards_println = {
	if True println n; // To test single-line if statements
	
	if 9 + 10 == 21 || 10 + 9 == 21
		println False
	else if 9 + 10 != 21 && !(10 + 9 == 21)
		if True { // To test nested if statements
			println True;
			println True;
		}
	else
		println False;
	
	println n;
};

backwards_println n; // Won't compile, since n must be 2 or more but that can't be guaranteed; n could be either 1 or 2

(typ) [] = Array typ 0 Void;

[(typ item) = {
	let addr = malloc (item size);
    @addr = item;
    Array typ 1 addr
};

Array (typ (len = 1|2|...) addr), (typ item) = {
	let addr = realloc addr (len + 1) * (typ size);
    @(addr + len * (typ size)) = item;
    Array typ (len + 1) addr
};

] = Void;

Array (arr) + (item) = arr, item;
Array (_ len _) length = len;
Array (typ) 1|2|... (addr)[Nat (i)] = @(addr + (typ size) * i);

let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

println numbers[4]; // 4

if rand 0 1 == 1
	numbers += 10;

// numbers = Array Nat 10|11 <addr>

println numbers length; // will print either 10 or 11