// Syntax sugar
$a                 <=> ($a as ...)
$(f $a $b [...])   <=> ($(f $a $b [...]) as $#0 $#1 [...])
(named_pattern)    <=> (_ as named_pattern)

--------------------------------------------------

// TODO: Fix so that stuff below works with new syntax

memo _ => (
	let basic $cache = [];
	
	$f $next $x => if cache.x exists (
		cache.x
	) else f (next) x
);

fibY $next $n => if n < 2 (
	1
) else next (next) (n - 2) + next (next) (n - 1);

// Better version?
basic func fibR $fibR $n {
	if n < 2 {
		1
	} else {
		fibR (fibR) (n - 2) + fibR (fibR) (n - 1)
	}
};

fibR (fibR) 123

// test impl
basic func rec func $pattern ($body _); {
	frozenraw (
		let basic pattern = (
			basic func $f pattern {
				let basic $pattern = (f) f;
				body _
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) fib $n' if pattern = 'fib $n'
		);
	)
};

rec func fib $n {
	if n < 2 {
		1
	} else {
		fib (n - 2) + fib (n - 1)
	}
};

=>

let basic fib $n = (
	basic func $f fib $n {
		let basic $(fib $n) = (f) f;
		if n < 2 {
			1
		} else {
			fib (n - 2) + fib (n - 1)
		}
	};

	($f fib $n) fib $n
);

fib 5

fibMemo $n => (fibY using memo) n;

--------------------------------------------------

// OLD Parsing instructions
(($(add (4) to ($(a) as 7)) as #a #0) => add 4 to 7) ($x _ => x + 4)
// NEW SYNTAX:                 $a $#0

1. Choose a $(...) and move to its outside
2. If inside another $(...), move to its outside, and then keep leaving scopes until you find 'as'
   If not, keep leaving scopes until you find '=>'
3. Your variable is defined after this 'as' or '=>'

-------------------------

// returns f c + a = f 456 + 123 = fu 123 nc 456 + 123
(($(f $b) as fu #($(a $f $x) as #(123) $f $x) nc $b) $c => f c + a) (fu 123 nc) 456

// returns f c + n = f 456 + 122 = fu 123 nc 456 + 122
// '122' is here below syntax sugar for 'PlusOne #121'
(($(f $b) as fu #(PlusOne ($n as 122)) nc $b) $c => f c + n) (fu 123 nc) 456

// ISSUE: if 'f' <=> 'f $x', then 'f $x' <=> '(f $x) $x' <=> '((f $x) $x) $x' <=> ...

--------------------------------------------------

Let f $x, $a f $b be patterns/functions

Then:
   f <=>    f $x
$a f <=> $a f $b

let f = $x => ...;
<=>
let f $x = $x => ...;

This is because there is no pattern matching before ‘as’. So doing ‘$x’ there serves no other purpose than naming the pattern / which order args come in.

Both patterns and anonymous functions can be passed around as values.

‘$x => ...’ is almost equivalent to ‘$x’.

All inputs to functions are parenthesised. They are also evaluated unless frozen.

--------------------------------------------------

Number literals can be linked to types for a certain scope. This allows changing the link for different scope, a.k.a. changing the representation (between for example machine and natural numbers).

// default representation, change part
// after ‘=‘ to change representation
let __NUMBERS__ = any Nat;
let __STRINGS__ = any String;

let n  = rand any Nat;
let n2 = rand any Nat;

// TODO: Fix so that func def order doesn't matter but variable order still does

let Even = Zero|(PlusOne (PlusOne Zero))|...;
let Even = even_zero|(even_plus2 Zero);
let Even = Zero|(EvenI Zero);

// needs lazy list, could be impl using permafrost '{}' and defrost during access
let Even = lazily flatten [Zero, EvenIL Zero]; // allows for Even.0, Even.2, etc.
let any Even = Zero|(EvenI Zero); // allows for '$n as any Even'

basic func any $b {orify b};

basic func orify $list {
	list[0]|list[1]|...
};

basic func use $module {
	if module.length > 0 {
		frozenraw (
			module[0];
			use module[1..];
		)
	}

	__caller_scope__
};

func even_zero {
	Zero
};

func even_plus2 $n {
	PlusOne (PlusOne n)
};

func EvenI $n {
	let next = PlusOne (PlusOne n);
	next|(EvenI next)
}

func EvenIL $n {
	let next = PlusOne (PlusOne n);
	[next, EvenI next]
}

--------------------------------------------------

func any ($cat as any List) {
	(if cat[0] is any List then any cat[0] else cat[0] (ALL_ARGS_BUT_ONE cat[0])) |
	(if cat length > 1 then any cat[1..] else (cat[0] (ALL_ARGS_BUT_ONE cat[0])))
};

func any $obj {obj (ALL_ARGS_BUT_ONE obj)};

func any of ($list as any List) {
	list[0] | if list length > 1 then any of list[1..] else list[0]
};

func $list.($field as frozen) {
	for each item in list {
		if item == frozen field {
			return item;
		}
	};

	Nothing
};

--------------------------------------------------

let field = frozen (Zero $x);
let item $x = Zero $x;

let n  $x = Zero $x;
let n2 $x = Zero $x;

n $x == n2 $x

(
	let Zero $x = $x => ;

	Zero $x

	/////////

	$(Zero $x) => (
		Zero $x
	) ($x => )
)

let item = (
	func Zero _ {};

	Zero
);

let item = item;

$(item $x) => (
	$(`item $x`) => (
		...
	) (item $x)
) (
	$(Zero $x) => (
		Zero $x
	) ($x => )
)

--------------------------------------------------

func use $module {
	frozenraw (
		let `module[0]` = module[0]; // using '``' to clarify the name is the evaluated module[0] rather than 'module[0]'
		if module length > 1 {
			use module[1..];
		};
	)
};

let Module = [
	f $a,
	0,
	g $x $y
];

any Module == f|0|(g _)|(g _)

let Nat = (
	func Zero _ {};
	func PlusOne ($n as Zero|(PlusOne _)) _ {};

	[Zero, PlusOne]
);

any Nat == Zero|(PlusOne Zero|(PlusOne _))

use Nat;

Zero                   == Nat.Zero
PlusOne (PlusOne Zero) == Nat.PlusOne (Nat.PlusOne Nat.Zero)

// TODO: Bring back operator defs in some way (before it was 'operator +;')
// TODO: Actually define 'let'. Apparently you forgot that and only 'let basic/pure' exists.

--------------------------------------------------

func $this where ($contract as frozen any Bool) {
	if contract then this
};

(0|1|2|3 where this mod 2 == 0): 0|2

--------------------------------------------------

// Something is an *object* if it's atomic or only contains properties of itself
object Player [
  $x      as any Int,
  $y      as any Int,
  $health as any Double
];

let HealthContract = frozen (
  this health > 50.0 &&
  this health < 100.0
);

// Something is a *category* if it contains objects that aren't properties of itself
let items = [
  Dirt,
  Stone,
  Wood
];

func throw ($item as any of items) from ($player as any Player fulfilling HealthContract) {...};

throw Stone   from (Player 123 456 75.0); // ok
throw Dirt    from (Player 123 456 75.0); // ok
throw Invalid from (Player 123 456 75.0); // ERROR
throw Stone   from (Player 123 456 30.0); // ERROR
throw Stone   from (Bird 123 456 75.0); // ERROR

// Maybe only use wrapper objects when there's an use for it?
// Use like Haskell constructors?
// Lists could be used for the types instead
module Nat [
	object Zero,
	object (Nat) PlusOne,

	let nats = [
		Zero,
		_ PlusOne
	],

	let Nat = any of nats
];

module Bool [
	object True,
	object False,

	let bools = [
		True,
		False
	],

	let Bool = any of bools
];

--------------------------------------------------
// Testing new potential syntax below

func category ($cat as permafrosted) ($contents as any List) {
	frozen raw (let `cat` = contents; contents)
};

// Currently doesn't do anything more than checking
// that what you're exporting is a list, which is
// useless since 'category' does that later anyway
func export ($exports as any List) {
	exports
};

// Currently imports files as raw, maybe it should
// automatically package them into categories?
func import ($filepath as any Path) {
	frozen raw defrost codify (read file filepath) // TODO: fix file reading
};

// If this conflicts with built-in 'as', rename to
// 'import ... and rename to ...'
func import ($filepath as any Path) as ($name as permafrosted) {
	category `name` (import filepath)
};

func expose ($cat as any List) {
	frozen raw (
		let `cat[0]` = cat[0]; // using '``' to clarify the name is the evaluated cat[0] rather than 'cat[0]'
		if cat length > 1 {
			expose cat[1..];
		};
	)
};

// This:
category Category (
	object Object  [$a, $b, ..., $z];
	object Object2 [$a, $b, ..., $z];
	...
	object ObjectN [$a, $b, ..., $z];

	export [
		Object,
		Object2,
		...,
		ObjectN
	]
);

// Becomes:
let Category = (
	func Object  $a $b ... $z _ {};
	func Object2 $a $b ... $z _ {};
	...
	func ObjectN $a $b ... $z _ {};

	// any Category => (any Object)|(any Object2)|...|(any ObjectN)
	[Object, Object2, ..., ObjectN]
);

// Unexposed use:
let obj:  any Category = Category.Object   _ _ ... _;
let obj2: any Category = Category.Object2  _ _ ... _;

// Exposed use:
expose Category;

let obj:  any Category = Object _ _ ... _;
let obj2: any Category = Object _ _ ... _;

// Example:
category Character (
	object Player [
		$health as Number
	];

	object NPC [
		$health as Number
	];

	// TODO:
	// Player and NPC share some similar properties; how to prevent code duplication?
	// Apparently Rust doesn't do anything about this; maybe it's not worth it?

	object NonExportedExperiment [
		$idk
	];

	export [Player, NPC]
);

// If 'Character' was in another file, we would also need to 'import' that file first
// TODO: Consider merging 'import' and 'expose' to Rust's 'use'
expose Character;

let player: any Character = Player 100;
let npc:    any Character = NPC 50;

player = npc; // works fine, because only restriction is that it stays a character

// Better:
let player: any Player = Player 100;
let npc:    any NPC    = NPC 50;

player = npc; // ERROR!
player = Player 80; // fine

category Bool (
	object True;
	object False;

	export all;
);

if Bool.True {
	println "always";
};

expose Bool;

if False {
	println "never";
};

False: any Bool;
True: any Bool;

Bool.False: any Bool;
Bool.True: any Bool;

// Bool is a special list where you can access items with '.'
// Kind of like JS objects
// Bool = [True, False]
any Bool == any of [Bool.True, Bool.False] == Bool.True|Bool.False

// Another example
category Shape (
  object Rectangle [
    $width,
    $height
  ];

  object Circle [
    $radius
  ];
  
  export all;
);

expose Shape; // so we don't need to type Shape.Circle and Shape.Rectangle all the time

let shape: any Shape = Circle 100; // ok
shape = Rectangle 300 150; // ok
shape = Bird 123; // ERROR

let shape2: any Circle = Circle 100; // ok
shape = Rectangle 300 150; // ERROR
shape = Circle 150; // ok

let shape3: Circle 100 = Circle 100; // ok
shape3 = Circle 150; // ERROR

--------------------------------------------------

impure func ($var as implicitly ref to 1|2|3 allowing 1|2|3 + val) += $val {
	var = var + val;
};

--------------------------------------------------

// Mutable dependent pairs?

// Second must be double of first
// 'dyn' means type is re-calculated every time
let [$a, $b]: dyn [any Int, this[0] * 2] = [123, 456];

a = 789; // ERROR

// Must assign both at once
[a, b] = [789, 1578]

[a, b] = [789, 678] // ERROR: second is not double of first

--------------------------------------------------

func extract from $list using $extractor {
	let extracts: any List = [];
	for each item in list {
		let extract = extractor index item;
		if extract != Nothing {
			extracts += extract;
		};
	};

	extracts
};

func extractor $index $item {
	if index mod 2 == 0 && item > 1 {
		item * item
	}
};

extract from [1, 2, 3, 4, 5] using extractor // [9, 25]

func index of $needle in $list {
	extract from list using $index $item => {
		if item == needle then index
	}
};

--------------------------------------------------

// par_type is "lower bound", a.k.a. par_type matches actual_par_type
// return_type is what's returned, which matches actual_return_type
($f as ($par as par_type) #($arg2 as arg2_type) ($par3 as par3_type) returning return_type)

// Example
func add ($x as any Int) and ($y as any Int) {
	x + y
}: any Int;

// "Can I give the function f a positive Int, and get back an Int?"
func apply ($f as ($par as 0..) ($par2 as 0..) returning any Int) and multiply {
	(f 123 456) * (f 456 789)
}: any Int;

// Alternatively, if 'Func' was defined somehow:
func apply ($f as Func[0.., 0..] returning any Int) and multiply {
	(f 123 456) * (f 456 789)
}: any Int;

apply (add $a and $b) and multiply; // => (123 + 456) * (456 + 789) => 579 * 1245 => 720855

--------------------------------------------------

// AST

object Object [
	$field  as any Field
	$field2 as any Field
];

=>

[
	"object",
	"Object",
	[
		"List",
		["as", "$field", ["any", "Field"]],
		[
			"List",
			["as", "$field2", ["any", "Field"]],
			Nothing
		]
	]
]

--------------------------------------------------

func __EVAL__ (List #$item #$tail) {
	let arr_ptr = malloc 24;

	ASSIGN arr_ptr        List_ID;
	ASSIGN (arr_ptr + 8)  item;
	ASSIGN (arr_ptr + 16) tail;

	arr_ptr
};

--------------------------------------------------

// Use 'implicitly' for more implicit stuff like below?

// replicate : a -> Vect n a
// replicate { n = Z }   val = []
// replicate { n = S k } val = val :: replicate val
// 
// from https://www.type-driven.org.uk/edwinb/papers/idris2.pdf

func replicate $val {[]}                   : any List;
func replicate $val {val :: replicate val} : any List;

let list: (implicitly any List where this length == 1) = replicate 123; // => 123 :: []

// Or maybe that's a bad idea? Better to only use 'implicitly' when truly necessary?
// https://contributors.scala-lang.org/t/can-we-wean-scala-off-implicit-conversions/4388

// Also would be nice to make it easier to have the same return type for several function variants

--------------------------------------------------

// Deno-style importing?
import { serve } from "https://deno.land/std@0.50.0/http/server.ts";

// Also maybe something similar to Deno safe-by-default permissions?
// https://deno.land/manual/getting_started/permissions

// Maybe also make the permissions more customisable?
// Ability to add your own permissions?

--------------------------------------------------

// Reactive expressions
// Runs once first, then re-runs whenever a variable has been updated
reactive: if count >= 10 {
	println "count is dangerously high!";
	count = 9;
};

--------------------------------------------------

// List comprehensions?

func transformed $x {
	let y = f(x);

	y if y correct else () // TODO: should returning '()' stop an item from being added to the list?
}

let transformed_items = each item in items recollected as transformed item;

// Python, Rust and others also have Iterables.
// 
// In Python you can have "generators", which
// have identical syntax to list comprehensions
// except with surrounding parentheses. These
// are kind of like "lazy" list comprehensions.
// 
// Maybe something similar for Triforce?

--------------------------------------------------

// Array programming in Triforce?

// Recursive multi-array for-each
rec for each [a, b] in [A, B] {
  R += a + b;
}

// i.e.
let X = [[1, 2], [3, 4]];
let Y = [[5, 6], [7, 8]];
let R: any List = [];
rec for each [x, y] in [X, Y] {
  R += x + y;
}

println R; // prints "[[6, 8], [10, 12]]"

// Then maybe you could using this define shortcuts for common operations:
func $arr $op..$op $arr2 {
  let res: any List = [];
  
  rec for each [a, b] in [arr, arr2] {
    res += a op b;
  }
  
  res
}

X +..+ Y // => '[[1+5, 2+6], [3+7, 4+8]]'
X /../ Y // => '[[1/5, 2/6], [3/7, 4/8]]'

--------------------------------------------------

// Implicit closures using macros
macro func f $x {
	func f ($x as T) {
		x() + 1
	}

	`` $$(f) (() => $$(x)) ``
}

--------------------------------------------------

// Math equations

let n = any suitable int; // <=> suitable of ...|-1|0|1|...

2*n + 1 :== 9; // equivalent to '(2*n + 1 == 9): True'
2*n     :== 8;
  n     :== 4; // "n should equal 4"

println n; // prints '4'

--------------------------------------------------

func assert_positive($n as 0|1|...) {}

// 'suitable': exclude what doesn't compile
// 'any suitable Int' <=> 'suitable of any Int'
func f($x as any suitable Int where this is even) { assert_positive(x) }
// <=>
func f($x as 0|2|...) { assert_positive(x) }

f(2);  // ok
f(-2); // err!


// Compare to this, which doesn't compile:
func f($x as any Int where this is even) { assert_positive(x) }
// <=>
func f($x as ...|-2|0|2|...) { assert_positive(x) } // fails assertion!

// Doesn't matter if we call with positive value;
// assertion still fails before any calls are evaluated.
f(2); // not evaluated!

--------------------------------------------------

// Haskell looks nice and clean like this...
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

// ... but that's not possible in Triforce.

// But maybe we could use a new '==>' syntax when fitting:
func fib ($n as any Int) --> any Int {
	// Here we put the definitions in a list to separate them,
	// but semicolons could also be used. That could however
	// cause some confusion with regards to if something is
	// returned or not.
	expose [
		fib (0) ==> 0,
		fib (1) ==> 1,
		fib $n  ==> fib (n-1) + fib(n-2)
	]

	fib n
}

// Compare to how it looks like without that syntax:
func fib ($n as any Int) --> any Int {
	func fib (0) { 0 }
	func fib (1) { 1 }
	func fib $n  { fib (n-1) + fib (n-2) }

	fib n
}

// And using this...
macro func multi func $declaration --> $ret_type {$defs} {
	``

	let $$(declaration) = {
		expose [$$(defs)];

		$$(declaration)
	}: _ => $$(ret_type); // only works if ':' is made a macro

	``
}

// ... we could write it simpler like this:
multi func fib ($n as any Int) --> any Int {
	fib (0) ==> 0,
	fib (1) ==> 1,
	fib $n  ==> fib (n-1) + fib(n-2)
}

--------------------------------------------------

// Multiple dispatch example
// Translated from Julia code shown in https://www.youtube.com/watch?v=kc9HwsxE1OY @ 7:02

let pet: _ = UNDEFINED; // maybe change to 'declare type pet' or 'let pet: anything = UNDEFINED'?

// Objects are values with properties
object Dog [$name as string]
object Cat [$name as string]

pet |= any Dog|Cat;

decl $($a meets $b); // maybe change to 'declare $a meets $b'?

func ($a as pet) encounters ($b as pet) {
	let verb = a meets b;
	println (a.name + " meets " + b.name + " and " + verb);
}

(any Dog) meets (any Dog) ==> "sniffs";
(any Dog) meets (any Cat) ==> "chases";
(any Cat) meets (any Dog) ==> "hisses";
(any Cat) meets (any Cat) ==> "slinks";

let fido     = Dog "Fido";
let rex      = Dog "Rex";
let whiskers = Cat "Whiskers";
let spots    = Cat "Spots";

fido     encounters rex;
fido     encounters whiskers;
whiskers encounters rex;
whiskers encounters spots;

// $ tric pets.tri
// 
// Fido meets Rex and sniffs
// Fido meets Whiskers and chases
// Whiskers meets Rex and hisses
// Whiskers meets Spots and slinks

--------------------------------------------------

// Minimal importing examples
import [a, b, ...] from "lib";
import all         from "lib";

// Importing examples showing all features
import [a as x, B.b as y, all in C, ...] from "lib" into Lib;
import all except [e1, e2, ...]          from "lib" into Lib;

// Access like:
println Lib.x;
println Lib.y;
println Lib.something_in_C;
println Lib.something_in_lib_thats_not_excepted;
println Lib.(function taking 123 and 456);       // equivalent to 'Lib.(function taking $x and $y) 123 456'

// Note: we can ofc also import functions and call them

{
	// Expose for a certain scope...
	expose Lib;

	// ... and you can simply do this within the scope:
	println x;
	println y;
}

// Note:
// Conflict with reserved keyword 'as' can probably be resolved
// by making only '({$(<...>)|_} as <...>)' reserved.

// Idea: also allow all of above but with 'export'? So you can forward exports, like:
export [AmongUsClient as Client] from "client";

category TranslationOfRustCodeExample {
	// Rust
	``
	extern crate clap;
	extern crate term_painter;

	use clap::{Arg, App};
	use term_painter::{ToStyle, Color::*};
	use kernel32::{GetConsoleMode, SetConsoleMode};

	use std::{
		fs,
		fs::File,
		io::prelude::*,
		io::ErrorKind,
		process::Command,
		path::PathBuf,
		str
	};
	``

	// Triforce
	import [Arg, App]                       from "clap";
	import [ToStyle, all in Color]          from "term_painter";
	import [GetConsoleMode, SetConsoleMode] from "kernel32";

	import [
		fs,
		fs.File,
		all in io.prelude,
		io.ErrorKind,
		process.Command,
		path.PathBuf,
		str
	] from "std";
}

--------------------------------------------------

// Notes on structured concurrency.
// https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/

func do_async_stuff_in($container as any AsyncContainer) {
	container.run_async(() => {
		// ...
	});
}

async container $container {
	container.run_async(some function);

	do_stuff_sync();

	do_async_stuff_in(container);

	container.run_async(another function);

	do_more_stuff_sync();
}

do_stuff_after_async_stuff_done();

--------------------------------------------------

// Prints contents of file.
// Python-style auto-closes file afterwards.
with file $file at "path/to/file.ext" open {
	println(contents of file);
}

--------------------------------------------------

// Adding 'where given' before closure-inputs sometimes improves readability

filter arr where given $item => item is even // read as-is but with '=>' unpronounced

map arr where given $item => item * 2 // read as-is but with '=>' pronounced as "return"

--------------------------------------------------

// Memory problems:
// - Deref pointers to dealloc memory
//   - i.e. out of scope, arr resize, @nullptr
// - Concurrency data races
// - Memory leaks

--------------------------------------------------

// Extending macro functions
// -------------------------

// Original definition
macro func if $cond then $tbody else $fbody {
	code {
		func if (True)  then $tbody else $fbody {tbody()}
		func if (False) then $tbody else $fbody {fbody()}

		if $$(cond) then
			() => $$(tbody)
		else
			() => $$(fbody)
	}
}

if True then println "yup" else "nope";
// =>
// yup

// Extension:
macro func if $cond then $tbody else $fbody {

	func if (True)  then _ else _ { println "It's true!";  }
	func if (False) then _ else _ { println "It's false!"; }

	if (eval cond) then tbody else fbody;

	// This last statement "switches" to the original definition of the function,
	// thereby allowing for this function to serve as an extension of the original.
	continue matching;
}

if True then println "yup" else println "nope";
// =>
// It's true!
// yup
