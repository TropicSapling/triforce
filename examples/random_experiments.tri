// Syntax sugar
$a                 <=> ($a as ...)
$(f $a $b [...])   <=> ($(f $a $b [...]) as $#0 $#1 [...])
(named_pattern)    <=> (_ as named_pattern)

--------------------------------------------------

// TODO: Fix so that stuff below works with new syntax

memo _ => (
	let basic $cache = [];
	
	$f $next $x => if cache.x exists (
		cache.x
	) else f (next) x
);

fibY $next $n => if n < 2 (
	1
) else next (next) (n - 2) + next (next) (n - 1);

// Better version?
basic func fibR $fibR $n {
	if n < 2 {
		1
	} else {
		fibR (fibR) (n - 2) + fibR (fibR) (n - 1)
	}
};

fibR (fibR) 123

// test impl
basic func rec func $pattern ($body _); {
	frozenraw (
		let basic pattern = (
			basic func $f pattern {
				let basic $pattern = (f) f;
				body _
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) fib $n' if pattern = 'fib $n'
		);
	)
};

rec func fib $n {
	if n < 2 {
		1
	} else {
		fib (n - 2) + fib (n - 1)
	}
};

=>

let basic fib $n = (
	basic func $f fib $n {
		let basic $(fib $n) = (f) f;
		if n < 2 {
			1
		} else {
			fib (n - 2) + fib (n - 1)
		}
	};

	($f fib $n) fib $n
);

fib 5

fibMemo $n => (fibY using memo) n;

--------------------------------------------------

// OLD Parsing instructions
(($(add (4) to ($(a) as 7)) as #a #0) => add 4 to 7) ($x _ => x + 4)
// NEW SYNTAX:                 $a $#0

1. Choose a $(...) and move to its outside
2. If inside another $(...), move to its outside, and then keep leaving scopes until you find 'as'
   If not, keep leaving scopes until you find '=>'
3. Your variable is defined after this 'as' or '=>'

-------------------------

// returns f c + a = f 456 + 123 = fu 123 nc 456 + 123
(($(f $b) as fu #($(a $f $x) as #(123) $f $x) nc $b) $c => f c + a) (fu 123 nc) 456

// returns f c + n = f 456 + 122 = fu 123 nc 456 + 122
// '122' is here below syntax sugar for 'PlusOne #121'
(($(f $b) as fu #(PlusOne ($n as 122)) nc $b) $c => f c + n) (fu 123 nc) 456

// ISSUE: if 'f' <=> 'f $x', then 'f $x' <=> '(f $x) $x' <=> '((f $x) $x) $x' <=> ...

--------------------------------------------------

Let f $x, $a f $b be patterns/functions

Then:
   f <=>    f $x
$a f <=> $a f $b

let f = $x => ...;
<=>
let f $x = $x => ...;

This is because there is no pattern matching before ‘as’. So doing ‘$x’ there serves no other purpose than naming the pattern / which order args come in.

Both patterns and anonymous functions can be passed around as values.

‘$x => ...’ is almost equivalent to ‘$x’.

All inputs to functions are parenthesised. They are also evaluated unless frozen.

--------------------------------------------------

Number literals can be linked to types for a certain scope. This allows changing the link for different scope, a.k.a. changing the representation (between for example machine and natural numbers).

// default representation, change part
// after ‘=‘ to change representation
let __NUMBERS__ = any Nat;
let __STRINGS__ = any String;

let n  = rand any Nat;
let n2 = rand any Nat;

// TODO: Fix so that func def order doesn't matter but variable order still does

let Even = Zero|(PlusOne (PlusOne Zero))|...;
let Even = even_zero|(even_plus2 Zero);
let Even = Zero|(EvenI Zero);

// needs lazy list, could be impl using permafrost '{}' and defrost during access
let Even = lazily flatten [Zero, EvenIL Zero]; // allows for Even.0, Even.2, etc.
let any Even = Zero|(EvenI Zero); // allows for '$n as any Even'

basic func any $b {orify b};

basic func orify $list {
	list[0]|list[1]|...
};

basic func use $module {
	if module.length > 0 {
		frozenraw (
			module[0];
			use module[1..];
		)
	}

	__caller_scope__
};

func even_zero {
	Zero
};

func even_plus2 $n {
	PlusOne (PlusOne n)
};

func EvenI $n {
	let next = PlusOne (PlusOne n);
	next|(EvenI next)
}

func EvenIL $n {
	let next = PlusOne (PlusOne n);
	[next, EvenI next]
}

--------------------------------------------------

func any ($cat as any List) {
	(if cat[0] is any List then any cat[0] else cat[0] (ALL_ARGS_BUT_ONE cat[0])) |
	(if cat length > 1 then any cat[1..] else (cat[0] (ALL_ARGS_BUT_ONE cat[0])))
};

func any $obj {obj (ALL_ARGS_BUT_ONE obj)};

func any of ($list as any List) {
	list[0] | if list length > 1 then any of list[1..] else list[0]
};

func $list.($field as frozen) {
	for each item in list {
		if item == frozen field {
			return item;
		}
	};

	Nothing
};

--------------------------------------------------

let field = frozen (Zero $x);
let item $x = Zero $x;

let n  $x = Zero $x;
let n2 $x = Zero $x;

n $x == n2 $x

(
	let Zero $x = $x => ;

	Zero $x

	/////////

	$(Zero $x) => (
		Zero $x
	) ($x => )
)

let item = (
	func Zero _ {};

	Zero
);

let item = item;

$(item $x) => (
	$(`item $x`) => (
		...
	) (item $x)
) (
	$(Zero $x) => (
		Zero $x
	) ($x => )
)

--------------------------------------------------

func use $module {
	frozenraw (
		let `module[0]` = module[0]; // using '``' to clarify the name is the evaluated module[0] rather than 'module[0]'
		if module length > 1 {
			use module[1..];
		};
	)
};

let Module = [
	f $a,
	0,
	g $x $y
];

any Module == f|0|(g _)|(g _)

let Nat = (
	func Zero _ {};
	func PlusOne ($n as Zero|(PlusOne _)) _ {};

	[Zero, PlusOne]
);

any Nat == Zero|(PlusOne Zero|(PlusOne _))

use Nat;

Zero                   == Nat.Zero
PlusOne (PlusOne Zero) == Nat.PlusOne (Nat.PlusOne Nat.Zero)

// TODO: Bring back operator defs in some way (before it was 'operator +;')
// TODO: Actually define 'let'. Apparently you forgot that and only 'let basic/pure' exists.

--------------------------------------------------

func $this where ($contract as frozen any Bool) {
	if contract then this
};

(0|1|2|3 where this mod 2 == 0): 0|2

--------------------------------------------------

// Something is an *object* if it's atomic or only contains properties of itself
object Player [
	$x      as any Int,
	$y      as any Int,
	$health as any Double
];

let HealthContract = frozen (
	this health > 50.0 &&
	this health < 100.0
);

// Something is a *category* if it contains objects that aren't properties of itself
let items = [
	Dirt,
	Stone,
	Wood
];

func throw ($item as any of items) from ($player as any Player fulfilling HealthContract) {...};

throw Stone   from (Player 123 456 75.0); // ok
throw Dirt    from (Player 123 456 75.0); // ok
throw Invalid from (Player 123 456 75.0); // ERROR
throw Stone   from (Player 123 456 30.0); // ERROR
throw Stone   from (Bird 123 456 75.0); // ERROR

// Maybe only use wrapper objects when there's an use for it?
// Use like Haskell constructors?
// Lists could be used for the types instead
module Nat [
	object Zero,
	object (Nat) PlusOne,

	let nats = [
		Zero,
		_ PlusOne
	],

	let Nat = any of nats
];

module Bool [
	object True,
	object False,

	let bools = [
		True,
		False
	],

	let Bool = any of bools
];

--------------------------------------------------
// Testing new potential syntax below

func category ($cat as permafrosted) ($contents as any List) {
	frozen raw (let `cat` = contents; contents)
};

// Currently doesn't do anything more than checking
// that what you're exporting is a list, which is
// useless since 'category' does that later anyway
func export ($exports as any List) {
	exports
};

// Currently imports files as raw, maybe it should
// automatically package them into categories?
func import ($filepath as any Path) {
	frozen raw defrost codify (read file filepath) // TODO: fix file reading
};

// If this conflicts with built-in 'as', rename to
// 'import ... and rename to ...'
func import ($filepath as any Path) as ($name as permafrosted) {
	category $$(name) {import filepath}
};

func expose ($cat as any List) {
	frozen raw (
		let `cat[0]` = cat[0]; // using '``' to clarify the name is the evaluated cat[0] rather than 'cat[0]'
		if cat length > 1 {
			expose cat[1..];
		};
	)
};

// UPDATE 2021-05-02, same function as above but with the new syntax:
macro func expose ($cat as any List) {
	let cat = eval cat;
	
	code {
		// using `$$()` to clarify the name is the evaluated `cat[0]` rather than 'cat[0]'
		let $$(cat[0]) = $$(cat[0]);
		if $$(cat) length > 1 {
			expose $$(cat[1..]);
		};
	}
};

// This:
category Category (
	object Object  [$a, $b, ..., $z];
	object Object2 [$a, $b, ..., $z];
	...
	object ObjectN [$a, $b, ..., $z];

	export [
		Object,
		Object2,
		...,
		ObjectN
	]
);

// Becomes:
let Category = (
	func Object  $a $b ... $z _ {};
	func Object2 $a $b ... $z _ {};
	...
	func ObjectN $a $b ... $z _ {};

	// any Category => (any Object)|(any Object2)|...|(any ObjectN)
	[Object, Object2, ..., ObjectN]
);

// Unexposed use:
let obj:  any Category = Category.Object   _ _ ... _;
let obj2: any Category = Category.Object2  _ _ ... _;

// Exposed use:
expose Category;

let obj:  any Category = Object _ _ ... _;
let obj2: any Category = Object _ _ ... _;

// Example:
category Character (
	object Player [
		$health as Number
	];

	object NPC [
		$health as Number
	];

	// TODO:
	// Player and NPC share some similar properties; how to prevent code duplication?
	// Apparently Rust doesn't do anything about this; maybe it's not worth it?

	object NonExportedExperiment [
		$idk
	];

	export [Player, NPC]
);

// If 'Character' was in another file, we would also need to 'import' that file first
// TODO: Consider merging 'import' and 'expose' to Rust's 'use'
expose Character;

let player: any Character = Player 100;
let npc:    any Character = NPC 50;

player = npc; // works fine, because only restriction is that it stays a character

// Better:
let player: any Player = Player 100;
let npc:    any NPC    = NPC 50;

player = npc; // ERROR!
player = Player 80; // fine

category Bool (
	object True;
	object False;

	export all;
);

if Bool.True {
	println "always";
};

expose Bool;

if False {
	println "never";
};

False: any Bool;
True: any Bool;

Bool.False: any Bool;
Bool.True: any Bool;

// Bool is a special list where you can access items with '.'
// Kind of like JS objects
// Bool = [True, False]
any Bool == any of [Bool.True, Bool.False] == Bool.True|Bool.False

// Another example
category Shape (
	object Rectangle [
		$width,
		$height
	];

	object Circle [
		$radius
	];

	export all;
);

expose Shape; // so we don't need to type Shape.Circle and Shape.Rectangle all the time

let shape: any Shape = Circle 100; // ok
shape = Rectangle 300 150; // ok
shape = Bird 123; // ERROR

let shape2: any Circle = Circle 100; // ok
shape = Rectangle 300 150; // ERROR
shape = Circle 150; // ok

let shape3: Circle 100 = Circle 100; // ok
shape3 = Circle 150; // ERROR

--------------------------------------------------

impure func ($var as implicitly ref to 1|2|3 allowing 1|2|3 + val) += $val {
	var = var + val;
};

--------------------------------------------------

// Mutable dependent pairs?

// Second must be double of first
// 'dyn' means type is re-calculated every time
let [$a, $b]: dyn [any Int, this[0] * 2] = [123, 456];

a = 789; // ERROR

// Must assign both at once
[a, b] = [789, 1578]

[a, b] = [789, 678] // ERROR: second is not double of first

--------------------------------------------------

func extract from $list using $extractor {
	let extracts: any List = [];
	for each item in list {
		let extract = extractor index item;
		if extract != Nothing {
			extracts += extract;
		};
	};

	extracts
};

func extractor $index $item {
	if index mod 2 == 0 && item > 1 {
		item * item
	}
};

extract from [1, 2, 3, 4, 5] using extractor // [9, 25]

func index of $needle in $list {
	extract from list using $index $item => {
		if item == needle then index
	}
};

--------------------------------------------------

// par_type is "lower bound", a.k.a. par_type matches actual_par_type
// return_type is what's returned, which matches actual_return_type
($f as ($par as par_type) #($arg2 as arg2_type) ($par3 as par3_type) returning return_type)

// Example
func add ($x as any Int) and ($y as any Int) {
	x + y
}: any Int;

// "Can I give the function f a positive Int, and get back an Int?"
func apply ($f as ($par as 0..) ($par2 as 0..) returning any Int) and multiply {
	(f 123 456) * (f 456 789)
}: any Int;

// Alternatively, if 'Func' was defined somehow:
func apply ($f as Func[0.., 0..] returning any Int) and multiply {
	(f 123 456) * (f 456 789)
}: any Int;

apply (add $a and $b) and multiply; // => (123 + 456) * (456 + 789) => 579 * 1245 => 720855

--------------------------------------------------

// AST

object Object has [
	$field  as any Field,
	$field2 as any Field
];

=>

[
	`object ... has ...`,
	`Object`,
	[
		`List ... ...`,
		[`... as ...`, [`$`, `field`], [`any ...`, `Field`]],
		[
			`List ... ...`,
			["... as ...", [`$`, `field2`], [`any ...`, `Field`]],
			Nothing
		]
	]
]

--------------------------------------------------

func __EVAL__ (List #$item #$tail) {
	let arr_ptr = malloc 24;

	ASSIGN arr_ptr        List_ID;
	ASSIGN (arr_ptr + 8)  item;
	ASSIGN (arr_ptr + 16) tail;

	arr_ptr
};

--------------------------------------------------

// Use 'implicitly' for more implicit stuff like below?

// replicate : a -> Vect n a
// replicate { n = Z }   val = []
// replicate { n = S k } val = val :: replicate val
// 
// from https://www.type-driven.org.uk/edwinb/papers/idris2.pdf

func replicate $val {[]}                   : any List;
func replicate $val {val :: replicate val} : any List;

let list: (implicitly any List where this length == 1) = replicate 123; // => 123 :: []

// Or maybe that's a bad idea? Better to only use 'implicitly' when truly necessary?
// https://contributors.scala-lang.org/t/can-we-wean-scala-off-implicit-conversions/4388

// Also would be nice to make it easier to have the same return type for several function variants

--------------------------------------------------

// Deno-style importing?
import { serve } from "https://deno.land/std@0.50.0/http/server.ts";

// Also maybe something similar to Deno safe-by-default permissions?
// https://deno.land/manual/getting_started/permissions

// Maybe also make the permissions more customisable?
// Ability to add your own permissions?

--------------------------------------------------

// Reactive expressions
// Runs once first, then re-runs whenever a variable has been updated
reactive: if count >= 10 {
	println "count is dangerously high!";
	count = 9;
};

--------------------------------------------------

// List comprehensions?

func transformed $x {
	let y = f(x);

	y if y correct else () // TODO: should returning '()' stop an item from being added to the list?
}

let transformed_items = each item in items recollected as transformed item;

let odd_doubles = each x in [1, 2, 3, 4, 5] recollected as x*2 if x odd; // [2, 6, 10]

// Or perhaps this below syntax is better?

func each $item [where|which $filter]? in $arr as $transformation;
func all [which $filter]? in $arr [$transformation]?;

let odd_doubles = each x where this is odd in [1, 2, 3, 4, 5] as x doubled;
let odd_doubles = each x which is odd in [1, 2, 3, 4, 5] as x doubled;
let odd_doubles = all which are odd in [1, 2, 3, 4, 5] doubled;

let arr = each x in [1, 2, 3, 4, 5] as 2*x + 1;

// When just filtering it might sound better with reversed order:
let arr = all in [1, 2, 3, 4, 5] which are odd;

// And sometimes inverse-filtering using 'excl' sounds better:
for each m in (matchs excl each m where m[0] != i) {
	...
}

// Alternative map syntax that fits better with for-loops:
for each m in (matchs with each m as 2*m + 1) {
	...
}

// Python, Rust and others also have Iterables.
// 
// In Python you can have "generators", which
// have identical syntax to list comprehensions
// except with surrounding parentheses. These
// are kind of like "lazy" list comprehensions.
// 
// Maybe something similar for Triforce?

--------------------------------------------------

// Array programming in Triforce?

// Recursive multi-array for-each
rec for each [a, b] in [A, B] {
	R += a + b;
}

// i.e.
let X = [[1, 2], [3, 4]];
let Y = [[5, 6], [7, 8]];
let R: any List = [];
rec for each [x, y] in [X, Y] {
	R += x + y;
}

println R; // prints "[[6, 8], [10, 12]]"

// Then maybe you could using this define shortcuts for common operations:
func $arr $op..$op $arr2 {
	let res: any List = [];

	rec for each [a, b] in [arr, arr2] {
		res += a op b;
	}

	res
}

X +..+ Y // => '[[1+5, 2+6], [3+7, 4+8]]'
X /../ Y // => '[[1/5, 2/6], [3/7, 4/8]]'

--------------------------------------------------

// Implicit closures using macros
macro func f $x {
	func f ($x as T) {
		x() + 1
	}

	`` $$(f) (() => $$(x)) ``
}

--------------------------------------------------

// Math equations

let n = any suitable int; // <=> suitable of ...|-1|0|1|...

2*n + 1 :== 9; // equivalent to '(2*n + 1 == 9): True'
2*n     :== 8;
  n     :== 4; // "n should equal 4"

println n; // prints '4'

// All of the `:` operators return their second argument,
// in order to make things like the following work properly:
x :< y :< z;
x :> y :> z;

10 :< 15 :< 20; // `:== (15 :< 20)` => OK
10 :< 20 :< 15; // `:== (20 :< 15)` => ERROR

1 + 2 + 3 :== 3 + 3 :== 6;

// Fuzzy Logic example:

func not $x {1 - x}

let x = ...;

x :== not x;
x :== 1 - x;
x :== 0.5;

--------------------------------------------------

func assert_positive($n as 0|1|...) {}

// 'suitable': exclude what doesn't compile
// 'any suitable Int' <=> 'suitable of any Int'
func f($x as any suitable Int where this is even) { assert_positive(x) }
// <=>
func f($x as 0|2|...) { assert_positive(x) }

f(2);  // ok
f(-2); // err!


// Compare to this, which doesn't compile:
func f($x as any Int where this is even) { assert_positive(x) }
// <=>
func f($x as ...|-2|0|2|...) { assert_positive(x) } // fails assertion!

// Doesn't matter if we call with positive value;
// assertion still fails before any calls are evaluated.
f(2); // not evaluated!

--------------------------------------------------

// Haskell looks nice and clean like this...
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

// ... but that's not possible in Triforce.

// But maybe we could use a new '==>' syntax when fitting:
func fib ($n as any Int) --> any Int {
	// Here we put the definitions in a list to separate them,
	// but semicolons could also be used. That could however
	// cause some confusion with regards to if something is
	// returned or not.
	expose [
		fib (0) ==> 0,
		fib (1) ==> 1,
		fib $n  ==> fib (n-1) + fib(n-2)
	]

	fib n
}

// Compare to how it looks like without that syntax:
func fib ($n as any Int) --> any Int {
	func fib (0) { 0 }
	func fib (1) { 1 }
	func fib $n  { fib (n-1) + fib (n-2) }

	fib n
}

// And using this...
macro func multi func $declaration --> $ret_type {$defs} {
	``

	let $$(declaration) = {
		expose [$$(defs)];

		$$(declaration)
	}: _ => $$(ret_type); // only works if ':' is made a macro

	``
}

// ... we could write it simpler like this:
multi func fib ($n as any Int) --> any Int {
	fib (0) ==> 0,
	fib (1) ==> 1,
	fib $n  ==> fib (n-1) + fib(n-2)
}

--------------------------------------------------

// Multiple dispatch example
// Translated from Julia code shown in https://www.youtube.com/watch?v=kc9HwsxE1OY @ 7:02

let pet: _ = UNDEFINED; // maybe change to 'declare type pet' or 'let pet: anything = UNDEFINED'?

// Objects are values with properties
object Dog has [$name as str]
object Cat has [$name as str]

pet |= any Dog|Cat;

decl $($a meets $b); // maybe change to 'declare $a meets $b'?

func ($a as pet) encounters ($b as pet) {
	let verb = a meets b;
	println (a.name + " meets " + b.name + " and " + verb);
}

(any Dog) meets (any Dog) ==> "sniffs";
(any Dog) meets (any Cat) ==> "chases";
(any Cat) meets (any Dog) ==> "hisses";
(any Cat) meets (any Cat) ==> "slinks";

let fido     = Dog "Fido";
let rex      = Dog "Rex";
let whiskers = Cat "Whiskers";
let spots    = Cat "Spots";

fido     encounters rex;
fido     encounters whiskers;
whiskers encounters rex;
whiskers encounters spots;

// $ tric pets.tri
// 
// Fido meets Rex and sniffs
// Fido meets Whiskers and chases
// Whiskers meets Rex and hisses
// Whiskers meets Spots and slinks

--------------------------------------------------

// Minimal importing examples
import [a, b, ...] from "lib";
import all         from "lib";

// Importing examples showing all features
import [a as x, B.b as y, all in C, ...] from "lib" into Lib;
import all except [e1, e2, ...]          from "lib" into Lib;

// Access like:
println Lib.x;
println Lib.y;
println Lib.something_in_C;
println Lib.something_in_lib_thats_not_excepted;
println Lib.(function taking 123 and 456);       // equivalent to 'Lib.(function taking $x and $y) 123 456'

// Note: we can ofc also import functions and call them

{
	// Expose for a certain scope...
	expose Lib;

	// ... and you can simply do this within the scope:
	println x;
	println y;
}

// Note:
// Conflict with reserved keyword 'as' can probably be resolved
// by making only '({$(<...>)|_} as <...>)' reserved.

// Idea: also allow all of above but with 'export'? So you can forward exports, like:
export [AmongUsClient as Client] from "client";

category TranslationOfRustCodeExample {
	// Rust
	``
	extern crate clap;
	extern crate term_painter;

	use clap::{Arg, App};
	use term_painter::{ToStyle, Color::*};
	use kernel32::{GetConsoleMode, SetConsoleMode};

	use std::{
		fs,
		fs::File,
		io::prelude::*,
		io::ErrorKind,
		process::Command,
		path::PathBuf,
		str
	};
	``

	// Triforce
	import [Arg, App]                       from "clap";
	import [ToStyle, all in Color]          from "term_painter";
	import [GetConsoleMode, SetConsoleMode] from "kernel32";

	import [
		fs,
		fs.File,
		all in io.prelude,
		io.ErrorKind,
		process.Command,
		path.PathBuf,
		str
	] from "std";
}

--------------------------------------------------

// Notes on structured concurrency.
// https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/

func do big calc concurrently in ($scope as any AsyncScope) {
	for each n in 0..65535 {
		// Do each calculation concurrently to speed things up.
		// `spawn` spawns a new thread (perhaps an actor like in Erlang?).
		spawn {
			let slow_calc = n^n;
			
			// TODO: figure out how to synchronise printing
			print "${n}^${n} = " + slow_calc + ", ";
		} in scope;
	}
	
	// Function exits here before calculations are finished.
	// They keep running in the background.
}

async scope scope {
	do big calc concurrently in scope;
	
	print "\n\nACCEPTING CONNECTIONS.\n\n";
	
	while accepting_connections {
		let incoming_connection = ...;
		
		spawn (handle connection incoming_connection) in scope;
	}
	
	print "\n\nNO LONGER ACCEPTING CONNECTIONS.\n\n";
	
	// Big calculations and connection handlers may still be running here.
	// If so the program will wait until they are done before exiting this block.
}

print "\n\nALL ASYNC PROCESSES FINISHED!\n\n";

--------------------------------------------------

// Concurrent map
macro func each $item in ($arr as [_]) as $trans {
	```
	
	let res: auto = [];
	
	async scope scope {
		for each $$(item) in $$(arr) {
			spawn {
				exclusively { // lock, alt. you could do Erlang-style messaging
					res += $$(trans);
				}
			} in scope;
		}
	}
	
	res
	
	```
}

let arr = each n in [1, 2, 3] as 2*n; //> [2, 4, 6]

--------------------------------------------------

// Prints contents of file.
// Python-style auto-closes file afterwards.
with file f at "path/to/file.ext" open {
	println(contents of f);
}

--------------------------------------------------

// Adding 'where given' before closure-inputs sometimes improves readability

filter arr where given $item => item is even // read as-is but with '=>' unpronounced

map arr where given $item => item * 2 // read as-is but with '=>' pronounced as "return"

// Or maybe it's unnecessary? Most people would probably understand anyway
// and figure out a fitting way to pronounce things.

--------------------------------------------------

// Memory problems:
// - Deref pointers to dealloc memory
//   - i.e. out of scope, arr resize, @nullptr
// - Concurrency data races
// - Memory leaks

--------------------------------------------------

// Extending macro functions
// -------------------------

// Original definition
macro func if $cond then $tbody else $fbody {
	code {
		func if (True)  then $tbody else $fbody {tbody()}
		func if (False) then $tbody else $fbody {fbody()}

		if $$(cond) then
			() => $$(tbody)
		else
			() => $$(fbody)
	}
}

if True then println "yup" else "nope";
// =>
// yup

// Extension:
macro func if $cond then $tbody else $fbody {

	func if (True)  then _ else _ { println "It's true!";  }
	func if (False) then _ else _ { println "It's false!"; }

	if (eval cond) then tbody else fbody;

	// This last statement "switches" to the original definition of the function,
	// thereby allowing for this function to serve as an extension of the original.
	continue matching;
}

if True then println "yup" else println "nope";
// =>
// It's true!
// yup

--------------------------------------------------

// Testing complex functions
// -------------------------

// Haskell
f2p :: (a -> (b, c)) -> (a -> b, a -> c)
f2p f = (fst . f, snd . f)

// Triforce?
func f2p ($f as $a => [#(#($b), #($c))]) --> [#(#($a => $b), #($a => $c))] {
	[$a => f(a)[0], $a => f(a)[1]] // or maybe with function composition operator: [[0] ¤ f, [1] ¤ f]
}

// TODO
// ----
// Think more about this:
// - Does this work out ok? Will $a, $b, $c be defined in return type?
// - Should syntax be changed? Is it perhaps too verbose?
//   - maybe syntax sugar or similar for list types?

--------------------------------------------------

// Sets are usually "automatically" unionised/flattened in Triforce:
{{1, 2, 3}, {4, 5}} <=> (1|2|3)|(4|5) <=> 1|2|3|4|5

// This is often beneficial, but could sometimes be problematic.
// Perhaps allowing sets to be represented both as list and or-patterns,
// and allowing easy conversion between the formats, could be of help?
orify [[1, 2, 3], [4, 5]] <=> (1|2|3)|(4|5)  <=> 1|2|3|4|5
orify [[1, 2, 3], [], []] <=> (1|2|3)|(|)|~_ <=> 1|2|3

--------------------------------------------------

// Allow moving out types into 'where' clauses?
// Compare the below functions:

func divide even ($a as int which mod 2 == 0) with ($b as int which != 0) --> int {
	...
}

func divide even $a with $b --> int
	where [
		a: int which mod 2 == 0,
		b: int which != 0
	]
{
	...
}

// Also just to demonstrate how flexible the 'where' clause is:
func divide ($a as even int) with $b --> int
	where [
		func even $x {x which mod 2 == 0}, // '=' within here defines rather than assigns

		non_zero_int = int which != 0,

		b: non_zero_int
	]
{
	...
}

// Note to self: if you for some reason feel like the 'where' clause isn't flexible enough,
// it's because that didn't work out well with reading things and made little sense.
// It doesn't make sense to i.e. print something in a 'where [we]' clause because for that
// you could just do this instead:
{
	println "hello";

	func divide even $a with $b --> int {...}
}
// The reading also got weird because function declarations are read in a declarative sense,
// while printing, etc. are read as imperative statements. It would become something like
// "function divide even a with b returns int" and then suddenly changing to imperative
// "where we let msg = ...; print msg;" and then back to declarative "has implementation"!
//
// Put it all together and you'll remember:
// "function 'divide even a with b' returns int, where we let msg = ... and print msg, and the function has the implementation:"
// Compare to the better:
// "function 'divide even a with b' returns int, where a is an int which is even, and has the implementation:"

--------------------------------------------------

/// Code blocks in comments (available for ST3):
/// 
/// ```
/// func divide even $a with $b --> int
/// 	where [
/// 		a: int which mod 2 == 0,
/// 		b: int which != 0
/// 	]
/// {
/// 	...
/// }
/// ```
/// 
/// More comment text here just to check that things work :)

println "Some code in-between";

/// If statements.
/// 
/// ```
/// if True  then println "yup" else "nope"; // prints "yup"
/// if False then println "yup" else "nope"; // prints "nope"
/// ```
macro func if $cond then $tbody else $fbody {
	code {
		func if (True)  then $tbody else $fbody {tbody()}
		func if (False) then $tbody else $fbody {fbody()}

		if $$(cond) then
			() => $$(tbody)
		else
			() => $$(fbody)
	}
}

--------------------------------------------------

func f($inp as num|str) {
	let a: auto = inp;

	// 'inp' is not changed after being assigned to 'a'
	// and 'a' is not changed either...

	if inp is num {
		// ... so inside here it knows 'inp' and 'a' must be numbers
		let n = a + 123; // and so this is allowed

		// but it still knows of the restriction
		// so it does allow this:
		a = "hello";
		a = 456;
		// but not this:
		a = SomeObjectThatsNotANumberNorString;
	}

	// Also, function parameters should probably be immutable by default,
	// similar to how it is with 'let' (this is the case in Rust).
	// Then the below statement wouldn't be allowed by default:
	inp = 789;

	// To allow mutation, Rust uses something similar to 'mut $inp'.
	// Nim simply forces you to do something like 'let inp: auto = inp'.
	// Btw, supposedly this immutability also increases performance.
}

--------------------------------------------------

/// # Basedlined strings
/// 
/// ## Similar concepts in other languages
/// - *Java*       : [text blocks](https://openjdk.java.net/jeps/378)
/// - *Scala*      : [multiline strings](https://docs.scala-lang.org/overviews/scala-book/two-notes-about-strings.html)
/// - *Python*     : [multiline strings](https://docs.python.org/3/library/textwrap.html)
/// - *Bash*       : [Heredocs](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_07_04)
/// - *Ruby*       : [Heredocs](https://www.rubyguides.com/2018/11/ruby-heredoc/)
/// - *Swift*      : [multiline string literals](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID286)
/// - *JavaScript* : [dedent proposal](https://github.com/tc39/proposal-string-dedent)
/// 
/// ## Algorithm
/// The below function, which will be defined in the prelude, modifies strings as follows:
/// 1. The first line is kept as-is, unless it is only whitespace; then it is removed.
/// 2. On the lines below, all indentation before the least-indented characters is removed.
/// 3. Additionally, the last line is removed if it is only whitespace.
func baselined ($s as str) --> str {...}

let unwanted_str = "This
					string
					spans
					multiple
					lines";

let str1 = baselined "This
					  string
					  spans
					  multiple
					  lines";

let str2 = baselined "
					 macro func if $cond then $tbody else $fbody {
						 code {
							 func if (True)  then $tbody else $fbody {tbody()}
							 func if (False) then $tbody else $fbody {fbody()}

							 if $$(cond) then
								 () => $$(tbody)
							 else
								 () => $$(fbody)
						 }
					 }
					 ";

let str3 = baselined "
	func divide even $a with $b --> int
		where [
			a: int which mod 2 == 0,
			b: int which != 0
		]
	{
		...
	}
";

// TODO: raw strings; no escaping required (incl. no escaping of "")

println unwanted_str;
// This
//                     string
//                     spans
//                     multiple
//                     lines

println str1;
// This
// string
// spans
// multiple
// lines

println str2;
// macro func if $cond then $tbody else $fbody {
//     code {
//         func if (True)  then $tbody else $fbody {tbody()}
//         func if (False) then $tbody else $fbody {fbody()}
// 
//         if $$(cond) then
//             () => $$(tbody)
//         else
//             () => $$(fbody)
//     }
// }

println str3;
// func divide even $a with $b --> int
//     where [
//         a: int which mod 2 == 0,
//         b: int which != 0
//     ]
// {
//     ...
// }

--------------------------------------------------

// Below is just for testing comments; it's not actual documentation

/// Converts the vector into `Box<[T]>`. This first paragraph is the summary. Everything
/// else will be folded by default once editor support for this is available.
/// 
/// ***Note** that this **will** drop any excess capacity.*
/// 
/// "Roses are Red,
/// Violets are Blue,
/// 
/// Unexpected '{'
/// on line 32."
/// 
/// # Examples
/// 
/// ```
/// let v     = vec![1, 2, 3];
/// let slice = v.into_boxed_slice();
/// ```
/// 
/// Any excess capacity is removed:
/// 
/// ```Triforce
/// let vec: auto = Vec::with_capacity(10);
/// vec.extend([1, 2, 3].iter().cloned());
/// 
/// assert_eq!(vec.capacity(), 10);
/// let slice = vec.into_boxed_slice();
/// assert_eq!(slice.into_vec().capacity(), 3);
/// ```
/// 
/// > macro func if $cond then $tbody else $fbody {
/// >     code {
/// >         func if (True)  then $tbody else $fbody {tbody()}
/// >         func if (False) then $tbody else $fbody {fbody()}
/// >         
/// >         if $$(cond) then
/// >             () => $$(tbody)
/// >         else
/// >             () => $$(fbody)
/// >     }
/// > }
func into_boxed_slice($self) --> Box<[T], A> {
	unsafe {
		self.shrink_to_fit();
		let me  = ManuallyDrop::new(self);
//>		let buf = ptr::read(&me.buf);
//>		let len = me.len();
		buf.into_box(len).assume_init()
	}
}

--------------------------------------------------

// Function bracket groups. `[group]?` = optional group.

// Here, the first and second groups are optional.
func [macro]? func $declaration [--> $ret_type]? \{$body} {
	...
}

// Here, both groups are NOT optional. In fact, the grouping is unnecessary here
// and might as well have been left out. For that reason, and to avoid confusion,
// having unnecessary groups like this will give a compiler warning. The warning
// will also come along with a suggestion to add '?' to the end.
func [macro] func $declaration [--> $ret_type] \{$body} {
	...
}

// Surrounding the entire function name in a group won't give a warning however,
// since it has an use and can't really cause much confusion. It's equivalent
// to surrounding with parentheses (except it also defines `[]#0`). This is also
// recommended over using parentheses since it can't be confused with a parameter,
// and really the brackets are the "parentheses of function names" you could say.
func [macro func $declaration --> $ret_type {$body}] {
	...
}

// Now, here comes a more advanced function with 2 nested groups.
// The first group is required, while the second one is optional.

//> macro func if $cond [then $tbody | {$tbody}] [else $fbody]? {
macro func if $cond [then $tbody | {$tbody}] [else [$fbody | {$fbody}]]? {
	// The function bracket groups can be accessed using the syntax `[]#n#m`.
	// Attempting to index out of bounds gives an error (obviously).
	// 
	// Here, `[]#0 is "then ..."|"{...}"` and `[]#1 is ""|"else [...]"`.
	// - an empty string means the group was not given when the function was called
	// 
	// Furthermore, if `[]#1 != ""` then `[]#1#0 is "..."|"{...}"`.
	// - if `[]#1` wasn't given, `[]#1#0` gives an error
	// - `[]#0#m` also gives an error since `[]#0` contains no groups
	
	// If else-body not provided, set it to `()`
	let fbody = fbody unless []#1 == "" then ();
//>	let fbody = fbody unless fbody is UNPROVIDED then ();
	
	code {
		func if (True)  then $tbody else $fbody {tbody()}
		func if (False) then $tbody else $fbody {fbody()}

		if $$(eval cond) then
			() => $$(eval tbody) // eval tbody == eval (code {xyz}) == xyz
		else
			() => $$(fbody)
	}
}

// 6 ways to call the above function:
// - if $cond then  $tbody
// - if $cond then  $tbody  else  $fbody
// - if $cond then  $tbody  else {$fbody}
// - if $cond      {$tbody}
// - if $cond      {$tbody} else  $fbody
// - if $cond      {$tbody} else {$fbody}

--------------------------------------------------

/// Calculates the nth fibonacci number.
/// Values above 50 are not accepted since they take forever to calculate.
/// 
/// # Examples
/// > fib 1 == 1
/// > fib 2 == 1
/// > fib 3 == 2
multi func fib ($n as 0..50) --> nat {
//>	let i: auto = 0; // maybe not loop actually
	
	fib (0) ==> 0,
	fib (1) ==> 1,
	fib $n  ==> fib (n-1) + fib (n-2)
}

--------------------------------------------------

// Macros, code and interpolation

// > literally   ident   => (ident_285b52f49ac52637)
// > literally ((ident)) => (ident_285b52f49ac52637)
// 
// > literally just   ident   => ident_285b52f49ac52637
// > literally just ((ident)) => ident_285b52f49ac52637
// 
// > literally unmangled   expr   => (expr)
// > literally unmangled ((expr)) => (expr)
// 
// `literally just` + `literally unmangled` = `literally as is`
// 
// > literally as is   expr   => expr
// > literally as is ((expr)) => expr
// 
// Also, mangling is not done on identifiers inserted using `$$(...)`, so assuming:
// > let x = literally as is ident;
// Then:
// > literally (println $$(x)) => (println (ident))

let name = literally as is fib;
let var  = literally as is n;

// Without `as is`, `fib` would turn into something like `(fib_317d481089b8c8fe)`
//> let name = literally fib;

macro func up to ($n as literally as is fifty) {
	let fifty = 50; 0..(eval n)
}

func ret $type {
	literally as is (--> $$(type))
}

// `$$just(x)` is shorthand for `$$(literally just $$(x))`
func $$just(name) ($($$just(var)) as up to fifty) $$just(ret nat) {
	...
}
// is equivalent to:
func fib ($(n) as 0..50) --> (nat) {
	...
}

--------------------------------------------------

if run (x is a|b|c|d|e|f) {
	...
}
// is equivalent to:
if run (x == a || x == b || x == c || x == d || x == e || x == f) {
	...
}

// NOTE: The 'run' is required. It ensures that all of the checks are done during runtime.
//		 Without it, the compiler will attempt to resolve some things during compilation,
//		 which will get weird because `a`, `b`, `c`, etc. probably don't have 1 known
//		 value until runtime.
if x is a|b|c|d|e|f {
	...
}
// here the compiler could for example see the above as this:
if 123|456 is (123|456)|789|12|(345|678)|912|3 { // `a = 123|456`, `b = 789`, etc.
	...
}
// <=>
if 123|456 is 123|456|789|12|345|678|912|3 {
	...
}
// <=>
if True {
	...
}
// which is not the expected result! What if `x = 123` at runtime? Then the result should
// be `False`, but the compiler deduced at compile time that it must be `True`!

// 'run' solves the problem since at runtime only intentional or-patterns can exist
// and not ones created by the compiler. All values will be known at runtime.

// ----------------

// Perhaps it's better to rename `is` to `is [a|an]` to avoid confusion?
let $x is [a|an] $t = $x matches $t; // TODO: let-bracket-group syntax highlighting!

// And then define a new, different function `is` like this:
func $x is $y {
	run (x is a y)
}

// Then, it's clear: the below sounds weird, so don't use it:
if x is an a|b|c|d|e|f {...}
// Instead:
if x is a|b|c|d|e|f {...}
// And only use `is [a|an]` with types (then it sounds right!):
if a is an int|str {...}

--------------------------------------------------

// Fuzzy Logic: `x :== !x` <=> `x :== 1 - x` <=> `x :== 0.5`
// Arthur Prior:
// - "This statement is false." <=> "This statement is true and this statement is false."
// - `x :== !x` <=> `x && x :== !x && x` <=> `x && x :== False` <=> `x :== False`

func "This sentence is not true" is true {
	//> !("This sentence is not true" is true)
	if "This sentence is not true" is true then
		!True :== False
	else
		!!True :== True
}

let the_answer = "This sentence is not true" is true;

the_answer is ~UNDEFINED: False; // the_answer = UNDEFINED

--------------------------------------------------

// Recursive variables are rarely useful, but can for example be used to build lists:
let n: int = 0;
let rec arr = [n++] + arr if n < 100 else []; // arr = [0, 1, ..., 99]

// More useful are recursive functions...
let rec fib $n = $n => {
	if n == 0 then 0 else
	if n == 1 then 1 else fib (n-1) + fib (n-2)
};

// ... which are more commonly written like this:
func fib $n {
	if n == 0 then 0 else
	if n == 1 then 1 else fib (n-1) + fib (n-2)
}

--------------------------------------------------

// Know the difference!

{
	// Defines an *immutable* variable and checks that it is an `int`
	let var = 123: int;
//>	let var = "hello world": int; // ERROR!

//>	var = 456; // ERROR!

	// Defines a *mutable* variable that must always stay an `int`
	let var: int = 123;

	var = 456;
//>	var = "not an int"; // ERROR!
}

--------------------------------------------------

// Units of measure - sketch based on F#
// https://docs.microsoft.com/en-us/archive/blogs/andrewkennedy/units-of-measure-in-f-part-one-introducing-units

// Unit decls & defs could be just like `let` except would define the units only within
// a special unit namespace making them only usable within `<...>`.
unit kg;
unit m;
unit s;

// New units can be created through multiplication and division of existing units.

unit N = kg*m/s^2; // or maybe `s**2` if `^` used for something else

let g = 9.81 <m/s^2>;

let andrew_office_height = 3.5 <m>;

let impact_speed = sqrt (2 * g * andrew_office_height): frac <m/s>;

// Adding or subtracting things with different units causes a unit mismatch.
// Here, we attempt to add `2*g: frac <m/s^2>` and `andrew_office_height: frac <m>`:
let impact_speed = sqrt (2 * g + andrew_office_height); // ERROR: unit mismatch

// Defining a different, non-unit `m` here. It's in a separate namespace => no conflict.
let m = 65 <kg>;
let F = m*g;

F: frac <kg*m/s^2>;
F: frac <N>;

println F; // "637.65 N" maybe, or maybe without the unit afterwards?

// This is a very incomplete sketch btw. Will need to think it through a lot more.

--------------------------------------------------

// Concurrency locks/mutexes & semaphores (= more generalised "availability locks")

exclusively  {...} ??? // or maybe just excl {...}? although keyword taken
synchronized {...} ??? // Java-style

when available {...} ??? // For semaphores. Needs better syntax...

// Or maybe objects should just get locked & unlocked automatically instead?
// Still though sometimes manual locking & unlocking will be necessary.

--------------------------------------------------

// Something like `@Override` in Java to prevent mistakenly defining new functions
// when you actually meant to override an already existing function?

// i.e. say we have a multiplication function:
func (a as num)*(b as num) {...}

// and we want to change its implementation; override it:
func (a as int)*(b as int) {...}
// but we accidentally type `int` instead of `num` and end up defining a new function*!

// With `##[Override]` (maybe different syntax though), this would error:
##[Override]
func (a as int)*(b as int) {...} // ERROR! Should be `num` not `int`!

// This way we won't unknowingly end up defining a new function when we meant to override!

// *Technically, you may say we're still overriding part of the implementation; the one
// for integers. But we're not fully overriding.

--------------------------------------------------

// OBJECTS
// -------

// Objects are values in the form of uncallable functions.
macro func [object $obj;] {
	`func [$$(obj)] (~_) {}`
}

// They are created like this:
object True;
object False;

// They may also have properties.
macro func object $obj has ($properties as [_]) {
	// -- Construct code for object definition --
	
	let code_str: auto = `func $$raw(obj)`;
	
	properties = eval properties;
	
	for each prop in properties {
		code_str += ` $$(prop)`;
		
		// Strip properties of `as ...`, so only `$prop` is left.
		// Needed for next section.
		prop = codified (listified `$$(prop)`)[1];
	}
	
	code_str += ` (~_) {}`;
	
	// -- Construct code for object property access functions --
	
	for each prop in properties {
		code_str += `macro func ($$raw(obj)`;
		
		for each prop in properties {
			code_str += ` #$$(prop)`;
		}
		
		code_str += `).(\`$$(prop[1..])\`) {\`\$\$$$(prop[1..])\`}`;
	}
	
	code_str
}

func $obj with ($props as any FieldList) { // TODO: define `FieldList`
	let obj_with_props: auto = obj;
	
	for each _ in props {
		for each prop in props {
			if prop name == current_prop_name??? { // TODO: define `current_prop_name`
				obj_with_props = obj_with_props (prop value);
			}
		}
	}
	
	obj_with_props
}

macro func $obj.$field {
	// TODO ...
	
	listified `$$(eval obj)`
}

// Here is an example object with properties:
object Cat has [
	$name as str,
	$age  as int
]

// Which macro expands into this:
func Cat ($name as str) ($age as int) (~_) {}

macro func (Cat #$name #$age).(`name`) {`$$(name)`}
macro func (Cat #$name #$age).(`age`)  {`$$(age)`}

// And can then be used to create objects like this:
let cat = Cat "Whiskers" 7;
// OR
let cat = Cat with [age = 7, name = "Whiskers"]; // order doesn't matter here
// OR
let cat: auto  = Cat;
cat.name = "Whiskers";
cat.age  = 7;

// It's also possible to have unnamed properties:
object Dog has [str, str]

// And objects with special syntax:
object (num)%;

let fifty_fifty = 50%;

// You can match objects like this:
func ($x as num) * (#($y)%) {
    x * y / 100
}

func greet senior (Cat with [name = #$name, age = 10..]) {
	println "Hello Sr. " + name;
}

greet senior cat; // ERROR: age too low

greet senior (Cat "Ziggy" 11); // Hello Sr. Ziggy

--------------------------------------------------

// `[_] == any List`
func ($list as [_])[last] {
	list[list length - 1]
}

// Better (?) syntax for the "fold"/"reduce" function:
func [$init_val]? $op (#$arr[0]) $op ... $op (#$arr[last]);
// Or perhaps a more general version:
func [$init_val]? $op (#$arr[#$a]) $op ... $op (#$arr[#$b]);

// `$init_val` is optional, but required if you want to support empty lists

// Used like this:
func sum $arr {
	0 + arr[0] + ... + arr[last] // 0 if list empty
}

func mul $arr {
	arr[0] * ... * arr[last] // error if list empty
}

// Note that "fold" is still not such a bad name though if you understand it.
// It's named as such because you "fold" a larger data structure (i.e. a list)
// repetitively until it becomes one small thing (i.e. a sum). Also, you can't just
// always fold left because it's efficient, since some operations require right folding.

--------------------------------------------------

// Code string syntax highlighting testing & comparison

return ```
	let not_first_arg: auto = False;
	for each section in function.structure {
		match section {
			FunctionSection::Arg(ref to name, ref to typ) => {
				if not_first_arg {
					output += ",";
				}
				
				output += name;
				output += "$$(ext)";
				output += \`:\`;
				output += ->compile_type(typ);
				
				not_first_arg = true;
			},
			
			_ => ()
		}
	}
```;

let str = 'let n: int = 123'; // not valid syntax; just for comparison
let str = `let n: int = 123`;
let str = "let n: int = 123";

let n = 123: int;

func if (True)  then $tbody else $fbody {tbody()}
func if (False) then $tbody else $fbody {fbody()}

if $$(eval cond) then
	() => $$(eval tbody) // eval tbody == eval (code {xyz}) == xyz
else
	() => $$(fbody)

```
let n = 123: int;

func if (True)  then $tbody else $fbody {tbody()}
func if (False) then $tbody else $fbody {fbody()}

if $$(eval cond) then
	() => $$(eval tbody) // eval tbody == eval (code {xyz}) == xyz
else
	() => $$(fbody)
```

"""
let n = 123: int;

func if (True)  then $tbody else $fbody {tbody()}
func if (False) then $tbody else $fbody {fbody()}

if $$(eval cond) then
	() => $$(eval tbody) // eval tbody == eval (code {xyz}) == xyz
else
	() => $$(fbody)
"""

macro func let \[$a, $b, $c] = \[$x, $y, $z] {
	```
	
	let $$(a) = $$(x);
	let $$(b) = $$(y);
	let $$(c) = $$(z);
	
	```
}

--------------------------------------------------

func newline count in ($s as str) --> int {
	count of (all which == '\n' in s)
}

func ($s as str) without first char --> str {
	s[1..]
}

func greet senior (Cat with [name = #($name), age = 10..]) {
	println "Hello Sr. " + name;
}

let string = "hello\nworld";

println (newline count in string); // 1

println (string without first char); // ello\nworld

greet senior cat;

for each m in (matchs excl each m where m[0] != i) {
	...
}

--------------------------------------------------

// Auto-executing function:
func just do it {
	println "just did it";
}

just do it; // prints "just did it"

let f = () => just do it; // turn back into normal function

f;   // does nothing
f(); // prints "just did it"

--------------------------------------------------

// If you want to, you can define functions a bit more classical style like this:
func f([#($par1), #($par2), #($par3)]) {
	...
}

// And then you call like this:
f[x, y, z]

// You can also have named arguments:
func f([arg1 = #($par1), arg2 = #($par2), arg3 = #($par3)]) {
	...
}

f[x, arg3 = z, arg2 = y] // out of order args allowed this way

// I'll admit it looks a bit uglier than the usual `f(par1, par2, par3)` though.
