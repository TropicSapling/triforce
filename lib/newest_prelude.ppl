// --------------------------------------------------
// |                  THE PRELUDE                   |
// --------------------------------------------------

// TODO: Put the basic things that are needed for the prelude but shouldn't be visible from the
//       outside inside a category 'Foundation'. This can be done by writing the category stuff
//       by hand using anonymous functions, or by generating these anonymous functions.
// OR:   Alternatively, put everything inside 'Prelude' category and then expose Prelude.

// TODO: Fix '@(precedence below ;)' for all functions using 'scope' (including all forms of 'let')
(impure $(let basic        $var = $val;) => scope) (       ($var as frozen code) $val => ($`var` => scope) val)
(impure $(let basic impure $var = $val;) => scope) (impure ($var as frozen code) $val => ($`var` => scope) val)

// TODO: 'let [$a as ..., $b as ..., ...] = <value>;' function which allows both multiple
//       definitions at once and destructuring of the value.

// Normal 'frozen' keyword only freezes until 'expr' gets used again.
// Use '{expr}' to permafrost 'expr'.
let basic {($expr as frozen)} _ = closed $expr _ => expr;
// Defrost with 'defrost {expr}'.
let basic defrost ($pfexpr as {_}) = $pfexpr => pfexpr _;

// We could've just used 'frozen' here. However, using permafrost forces the user to explicitly
// write '{}', thereby making them aware of the code not being evaluated until later.
// It's convention to make this explicit as long as it doesn't negatively affect user experience.
let basic               basic func ($pattern as frozen code) ($body as {_}); = $pattern $body => frozenraw (let basic        $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);
let basic impure impure basic func ($pattern as frozen code) ($body as {_}); = $pattern $body => frozenraw (let basic impure $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);

basic func declare ($var as frozen code) {
	decl $`var` in scope
};

basic func Typed $expr $type _ {};

// If all pattern matching fails, throw away type restriction
basic func __CATCH__ (Typed #$expr _) {expr};

// Pronounced as: "$expr [should] be[come] type"
basic func (Typed #$expr _): $type {expr: type}; // allows for stuff like '(n: 0..): any Int' changing the type of 'n'
basic func ($expr as type ): $type {Typed expr type};
basic func ($expr as {_}  ): $type {(_ => Typed expr type) (defrost expr: type)}; // allows for stuff like '{123}: any Int'

basic func ($expr as type) matches $type {True};
basic func ($expr as {_} ) matches $type {defrost expr matches type};
basic func _               matches $type {False};

// 'REF' acts similarly to 'frozen code' when it comes to evaluation
basic func ($var as REF (Typed _ #$type)) = ($val as type) {
	ASSIGN var (Typed val type)
};

func ($var as ref to 1|2|3 allowing change to 1|2|3 + val) += $val {
	var = var + val;
};

func ref to ($val as frozen code) allowing change to ($sub as frozen code) {
	frozenraw (REF (Typed val #$super) where sub matches super)
};

func ref to ($val as frozen code) {
	ref to val allowing change to val
};