// --------------------------------------------------
// |                  THE PRELUDE                   |
// --------------------------------------------------

// TODO: Put the basic things that are needed for the prelude but shouldn't be visible from the
//       outside inside a category 'Foundation'. This can be done by writing the category stuff
//       by hand using anonymous functions, or by generating these anonymous functions.
// OR:   Alternatively, put everything inside 'Prelude' category and then expose Prelude.

// -------------------------
// |   CATEGORY: Tokens    |
// -------------------------

decl symblock sb_line_comment  enclosed by // \n;
decl symblock sb_multi_comment enclosed by /* */;

decl symblock __sb_default_str__ enclosed by " " with escaper \;

decl symindies { } [ ];

// -------------------------
// |   CATEGORY: Basics    |
// -------------------------

// Defines a semi-permanent version of 'frozen' that can be defrosted.
// You could say that 'permafrosted $expr' is '$expr' in the freezer,
// and 'defrosted $pfexpr' is '$pfexpr' out of the freezer again.
// The freezer is here a frozen argument slot.
($permafrosted => __caller_scope__) (($expr   as implicitly frozen    ) () => ()         )
($defrosted    => __caller_scope__) (($pfexpr as permafrosted #($expr))    => frozen expr)

// TODO: Fix '##(precedence below ;)' for all functions using '__caller_scope__' (including all forms of 'let')
(unpredictable $(let basic $var = $val;) => __caller_scope__) (($var as implicitly unchecked permafrosted) $val => (unpredictable $`frozen (defrosted var)` => __caller_scope__) val)

// TODO: 'let [$a as ..., $b as ..., ...] = <value>;' function which allows both multiple
//       definitions at once and destructuring of the value.

// TODO: Declare operators using symgroups:
// - {}
// - []
// - ;
// - +-*/%
// - etc.

// TODO: Define 'debug $expr' function similar to Rust's 'dbg!(...)'

// Useless, but looks nice sometimes.
// Convention to use this whenever $expr spans multiple lines.
// Also use this for the classics 'func', 'if', etc.
let basic {$expr} = $expr => expr;

let basic basic func ($pattern as implicitly unchecked permafrosted) ($body as implicitly unchecked frozen); = $pattern $body => frozen raw (let basic `pattern` = __all_args_placeholders__ pattern => body;);

basic func Typed $expr $type () {};
// If all pattern matching fails, throw away type restriction
basic func __catch__ (Typed #$expr _) {expr};

// Pronounced as: "$expr [should] be[come] type"
basic func ($expr as type ): $type {Typed expr type};
basic func (Typed #$expr _): $type {expr: type}; // allows for stuff like '(n: 0..): any Int' changing the type of 'n'

basic func any $obj {obj (__all_args_but_one__ obj)};

// TODO: getting category of value and doing 'any <category>'
// i.e. 'type of Player 50 100' => 'Player _ _'
basic func type of (_ constructed using $constructor) {any constructor};

// Marker for unchecked input
// File reading, user input, etc. should use this
// Always ensure raw input is ~UncheckedInput
// TODO: Make '__catch__' for this or not?
basic func UncheckedInput () {};

// Pronounced as: "let $var be $type and equal $val"
// let impure $var = $val also works (thanks to 'raw')
basic func let ($var as implicitly unchecked permafrosted raw ~UncheckedInput): $type = $val; {
	frozen raw (let basic `var` = val: type;)
};

basic func let ($var as implicitly unchecked permafrosted): auto = $val; {
	frozen raw (let `var`: type of val = val;)
};

basic func let ($var as implicitly unchecked permafrosted) = $val; {
	frozen raw (let `var`: val = val;)
};

// Useful for distinguishing '()' from 'Wrapped ()'
// See https://www.reddit.com/r/ProgrammingLanguages/comments/hy6emx/explicit_nullability_vs_optionals/fzarbwu/
basic func Wrapped $obj () {};

basic func List $item ($tail as any List) () {};

// This sets the default list to 'List' and returns nothing
__set_default_list__ List

// Does not accept unchecked input for security reasons
basic func rec basic func ($pattern as implicitly unchecked permafrosted raw ~UncheckedInput) ($body as implicitly frozen); {
	frozen raw {
		let `pattern` = {
			basic func $f `pattern` {
				let `pattern` = f f;
				body
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) ($f fib $n)' => '(($f fib $n) fib $n)' if pattern = 'fib $n'
		};
	}
};

basic func impure rec basic func ($pattern as implicitly unchecked permafrosted raw ~UncheckedInput) ($body as implicitly frozen); {
	frozen raw {
		let impure `pattern` = {
			impure basic func $f `pattern` {
				let `pattern` = f f;
				body
			};
			
			($f pattern) ($f pattern)
		};
	}
};

// Complete *total* functions: allows easy attributes, recursion & types
// - a total function must return, meaning it must:
//		- have no (possibly) infinite loops
//		- have no possibility of crashing
// Note: adding 'impure' before '[partial] func' works since 'impure rec func' exists
basic func ##($attrs as implicitly unchecked permafrosted any List) func ($pattern as implicitly unchecked permafrosted) ($typed_body as implicitly unchecked frozen); {
	frozen raw {
		// This built-in tells compiler 'pattern' has attributes 'attrs'
		// and returns 'pattern' as permafrosted. The attributes must
		// be given using the default list.
		rec basic func `__set_attributes__ attrs pattern` {typed_body: ~Undefined};
	}
};

// Complete *partial* functions (I know that sounds contradicting but it's not actually so yeah xD)
basic func ##($attrs as implicitly unchecked permafrosted any List) partial func ($pattern as implicitly unchecked permafrosted) ($typed_body as implicitly unchecked frozen); {
	frozen raw {
		rec basic func `__set_attributes__ attrs pattern` {typed_body};
	}
};

basic func         func ($pattern as implicitly unchecked permafrosted) ($typed_body as implicitly unchecked frozen); {[]         func `pattern` {typed_body};};
basic func partial func ($pattern as implicitly unchecked permafrosted) ($typed_body as implicitly unchecked frozen); {[] partial func `pattern` {typed_body};};

// TODO: Add ability to provide return type before function body?
// ----
// Maybe using '-->' operator? Since '->' is taken for pointers.

// The legendary SEMICOLON
##[precedence below _]
func $expr; {};

// '->' means 'pointer/ref to' and acts similarly to 'permafrosted' when it comes to evaluation
impure func ($var as implicitly ->(Typed _ #$type)) = ($val as type) {
	__assign__ var (Typed val type)
};

func ref to $val allowing $sub {
	frozen raw (->(Typed val #$super) where sub matches super)
};

func ref to $val {
	ref to val allowing val
};

// -------------------------
// |    CATEGORY: Bool     |
// -------------------------

func True  () {};
func False () {};

func (True)  && ($b as any Bool)                      {b};
func (False) && (implicitly frozen becoming any Bool) {False};

func (True)  || (implicitly frozen becoming any Bool) {False};
func (False) || ($b as any Bool)                      {b};

func !(True)  {False};
func !(False) {True};

// -------------------------
// | CATEGORY: Comparison  |
// -------------------------

func $a == $a {True};
func _  == _  {False};
func $a != $b {!(a == b)};

func ($expr as type) matches $type {True};
func _               matches $type {False};

let $expr is $type = $expr matches $type;

// Useful for ruling out potential runtime scenarios at compile time
// True|False could be True, but !(False could be True)
func $a could be $b {b matches a};

// -------------------------
// |   CATEGORY: Control   |
// -------------------------

// ex: 'if x == 123 {456} else {789}'
func if (True)  ($body as implicitly frozen)                                   {body};
func if (False) ($body as implicitly frozen)                                   {};
func if (True)  ($body as implicitly frozen) else ($expr as implicitly frozen) {body};
func if (False) ($body as implicitly frozen) else ($expr as implicitly frozen) {expr};

// ex: 'if x == 123 then 456 else 789'
func if $cond then ($body as implicitly frozen)                                   {if cond {body}};
func if $cond then ($body as implicitly frozen) else ($expr as implicitly frozen) {if cond {body} else {expr}};

// ex: 'return 123 if x == 456 else 789;'
func ($body as implicitly frozen) if $cond else ($expr as implicitly frozen) {if cond then body else expr};

func while ($cond as any Bool) ($body as implicitly frozen) {
	// TODO ...
};

func for each $item in ($list as any List) ($body as implicitly frozen) {
	// TODO ...
};

// -------------------------
// |   CATEGORY: Number    |
// -------------------------

// Inclusive range
func $n..$m {
	if m > n then
		n|(n + 1)|...|m
	else if m == n then
		n
	else
		()
};

// Exclusive range
func $n..<$m {
	n..(m - 1)
};

func $n +- $m {n-m..n+m};

// -------------------------
// |  CATEGORY: Category   |
// -------------------------

// TODO: Move out of prelude into std lib if possible.
// Ex: 'fieldified [$a as 123, $b as any Int]' => AST: [["as", "$a", "123"], ["as", "$b", ["any", "Int"]]]
func fieldified ($fields as any List) {
	let AST: any List = [];

	for each field in fields {
		AST += listified permafrosted `field`; // note how the field is parenthesised (add 'raw' to avoid this)
	};

	AST // = [["as", "$field", "<type>"], ["as", "$field2", "<type2>"], ...]
};

func object ($obj as implicitly unchecked permafrosted) ($fields as any List); {
	frozen raw (func `obj` `raw codified fieldified fields` () {};)
};

func object ($obj as implicitly unchecked permafrosted); {
	frozen raw (object `obj` [])
};

func category ($cat as implicitly unchecked permafrosted) ($contents as any List) {
	frozen raw (let `cat` = contents; contents)
};

// Currently doesn't do anything more than checking
// that what you're exporting is a list, which is
// useless since 'category' does that later anyway
func export ($exports as any List); {
	exports
};

func expose ($cat as any List) {
	frozen raw {
		// Nothing in this block is evaluated until after returning.
		// This block captures variables, functions, etc.
		// Captures have precedence over what is defined in __caller_scope__.
		// I.e. if __caller_scope__ defines another 'cat' that will be ignored.
		// We could still put something undefined in here though and it would
		// still compile if __caller_scope__ defines that thing.

		let `cat[0]` = cat[0]; // using '``' to clarify the name is the evaluated cat[0] rather than 'cat[0]'
		if cat length > 1 {
			expose cat[1..];
		};
	}
};

// -------------------------
// |   PROPER CATEGORIES   |
// -------------------------

category Misc {
	func optionally ($x as _) {x|()};

	// TODO: Move into more fitting category
	func [                          ] {List $item ()};
	func [$expr as implicitly frozen] {
		// We need this object to allow for multi-dimensional Lists
		object CommaList [
			$item,
			$tail as any CommaList
		];

		func ($x as CommaList #($item) #($tail)), $y { CommaList item (tail, y)        };
		func ($x as CommaList #($item) #()     ), $y { CommaList item (CommaList y ()) };
		func ($x                               ), $y { CommaList x    (CommaList y ()) };

		func ($expr as CommaList #($item) #($tail)) converted to (List) { List item (tail converted to List) };
		func ($expr as CommaList #($item) #()     ) converted to (List) { List item () };

		expr converted to List
	};

	// TODO: list[i] access syntax

	// TODO: Generalise into 'apply $f to itself $n times'
	// TODO: Move out of prelude into std lib
	func apply $f to itself {f f};

	export [optionally];
};

expose Misc;
