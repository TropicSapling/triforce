// Syntax sugar
$a                 <=> ($a as _) // 'a' can be called like 'a arg1 arg2 ...'
$(f $a $b ...)     <=> ($(f $a $b ...) as $#0 $#1 ...)
(x)                <=> (_ as x) // where 'x' is not '$a' ('$a b' is allowed and will become '_ as $a b')
// EDIT: should that last sugar be removed? might just be confusing to have it

////////////////////////////////////////////////////////////////

// TODO: Fix '@(precedence below ;)' for all functions using 'scope' (including all forms of 'let')
(impure $(let basic $var = $val;) => scope) (impure ($var as frozen) $val => (var => scope) val)
(impure $(let pure  $var = $val;) => scope) (       ($var as frozen) $val => (var => scope) val)

// Normal 'frozen' keyword only freezes until 'expr' gets used again.
// Use '{expr}' to permafrost 'expr'. Defrost with 'defrost {expr}'.
let basic $({($expr as frozen)} _)           = $expr   _ => expr;
let basic $(permafrosted ($input as frozen)) = $input    => frozen ($(`input` _));
let basic $(defrost (permafrosted $pfexpr))  = $pfexpr   => pfexpr _;

// We could've just used 'frozen' here. However, using permafrost
// forces the user to explicitly write '{}', thereby making them
// aware of the code not being evaluated until later.
// It's convention to make this explicit as long as it
// doesn't negatively affect user experience.
let basic $(       basic func ($pattern as frozen) (permafrosted $body);) = $pattern $body => frozenraw (let pure  $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);
let basic $(impure basic func ($pattern as frozen) (permafrosted $body);) = $pattern $body => frozenraw (let basic $`pattern` = ALL_ARGS_PLACEHOLDERS pattern => defrost body;);

// NOTE: Basic functions:
// - must be defined in order
// - don't allow easy attributes
// - don't allow easy recursion
// - don't allow easy return type checking

basic func Nothing $f $x {scope};

basic func remaining args of $f {
	ALL_ARGS f length - APPLIED_ARGS f length
};

basic func call $f {f (ALL_ARGS f)};

// Boxes
basic func category of ($wrapper (ALL_ARGS_PLACEHOLDERS wrapper)) {wrapper};
basic func unbox $b {APPLIED_ARGS b};

// Bool True|False
basic func Bool True  $x _  {x};
basic func Bool False _  $y {y};

let basic $True  = Bool True;
let basic $False = Bool False;

basic func (True)  && ($b as           Bool _) {b};
basic func (False) && (frozen becoming Bool _) {False};

basic func (True)  || (frozen becoming Bool _) {False};
basic func (False) || ($b as           Bool _) {b};

basic func !(True)  {False};
basic func !(False) {True};

basic func $a == $a {True};
basic func _  == _  {False};
basic func $a != $b {!(a == b)};

// if _ _ else
// ex: 'if x == 123 {456} else {789}'
basic func if (True)  `permafrosted $body`                           {defrost body};
basic func if (False) `permafrosted $body`                           {scope};
basic func if (True)  `permafrosted $body` else `permafrosted $expr` {defrost body};
basic func if (False) `permafrosted $body` else `permafrosted $expr` {defrost expr};

// if _ then _ else _
// ex: 'if x == 123 then 456 else 789'
basic func if $cond then ($body as frozen)                        {if cond {body}};
basic func if $cond then ($body as frozen) else ($expr as frozen) {if cond {body} else {expr}};

// Type checking
basic func any $b {b (ALL_ARGS_BUT_ONE b)};

basic func if fulfilling (True)                       `permafrosted $body` {body};
basic func if fulfilling ($contract as frozen Bool _) `permafrosted $body` {
	// continue to next function def if there is one, else panic
	continue from caller or alt prerun panic (format_err (format "Failed to fulfill condition '{}'" [stringify {contract}]))
};

basic func if fulfilling (True)  `permafrosted $body` else report _             {body};
basic func if fulfilling (False) `permafrosted $body` else report (String $msg) {
	continue from caller or alt prerun panic (format_err (String msg))
};

basic func $this fulfilling ($contract as frozen Bool _) {
	// Note that the structure of this function allows 'this' to be used inside of the contract
	if !contract {
		continue from caller or alt prerun panic (format_err (format "Failed to fulfill condition '{}'" [stringify {contract}]))
	};
};

// 'arr: any Array where this length == 7' sounds better than 'arr: any Array fulfilling this length == 7'
let basic $where = fulfilling;

// Pronounced as: "$expr [should] be[come] type"
basic func (Typed $expr _     ): $type {expr: type}; // allows for stuff like '(123: 0..): any Int'
basic func ($expr as type     ): $type {Typed expr type};
basic func `permafrosted $expr`: $type {(_ => Typed expr type) (defrost expr: type)}; // allows for stuff like '{123}: any Int'

basic func ($expr as type     ) matches $type {True};
basic func `permafrosted $expr` matches $type {defrost expr matches type};
basic func _                    matches $type {False};

// TODO:
// Fix permafrost, either by adding here or by changing lang spec so that
// frozen/permafrost/etc. are automatically fixed for synonyms
let basic $expr is $type = $expr matches $type;

// 'transparent _' makes this function run if all previous pattern matches failed
basic func Typed $expr $type (transparent _) {expr};

// TODO: Generalise into 'apply $f to itself $n times'
basic func apply $f to itself {f f};

basic func $f using $closure {
	if fulfilling remaining args of closure == 1 {
		f ((closure _) f)
	};
};

basic func @($attr as frozen) ($id as frozen) {
	ATTRIBUTE attr id // this built-in tells compiler 'id' has attribute 'attr' and returns 'id'
}; // use '##' instead if you decide to use '@' for pointers

basic func rec func ($pattern as frozen) `permafrosted $body`; {
	frozenraw (
		let basic $`pattern` = (
			basic func $f `pattern` {
				let basic $`pattern` = f f;
				defrost body
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) ($f fib $n)' => '(($f fib $n) fib $n)' if pattern = 'fib $n'
		);
	)
};

basic func impure rec func ($pattern as frozen) `permafrosted $body`; {
	frozenraw (
		let basic $`pattern` = (
			impure basic func $f `pattern` {
				let basic $`pattern` = f f;
				defrost body
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) ($f fib $n)' => '(($f fib $n) fib $n)' if pattern = 'fib $n'
		);
	)
};

// Complete *total* functions: allows easy attributes, recursion & types (TODO: allow out-of-order definitions as well)
// - a total function must:
//		- have no infinite loops
//		- cause no side-effects
//		- use no outside/free patterns
// Note: adding 'impure' before '[partial] func' works since 'impure rec func' exists
basic func $attr_list func ($pattern as frozen) ($typed_body as frozen becoming {#_}); {
	frozenraw (
		rec func (attr_list pattern) (typed_body: ~Undefined);
	)
};

// Complete *partial* functions (I know that sounds contradicting but it's not actually so yeah xD)
basic func $attr_list partial func ($pattern as frozen) ($typed_body as frozen becoming {#_}); {
	frozenraw (
		rec func (attr_list pattern) (typed_body);
	)
};

basic func         func ($pattern as frozen) ($typed_body as frozen becoming {#_}); {[]         func pattern body;};
basic func partial func ($pattern as frozen) ($typed_body as frozen becoming {#_}); {[] partial func pattern body;};

// The legendary SEMICOLON
@(precedence below _) // this is a function and not a list of attrs, needs fixing
func $expr; {
	scope
};

// TODO: Fix so that stuff below works with new syntax

memo _ => (
	let basic $cache = [];
	
	$f $next $x => if cache.x exists (
		cache.x
	) else f (next) x
);

fibY $next $n => if n < 2 (
	1
) else next (next) (n - 2) + next (next) (n - 1);

// Better version?
basic func fibR $fibR $n {
	if n < 2 {
		1
	} else {
		fibR (fibR) (n - 2) + fibR (fibR) (n - 1)
	}
};

fibR (fibR) 123

// test impl
basic func rec func $pattern ($body _); {
	frozenraw (
		let basic pattern = (
			basic func $f pattern {
				let basic $pattern = (f) f;
				body _
			};
			
			($f pattern) ($f pattern) // becomes '($f fib $n) fib $n' if pattern = 'fib $n'
		);
	)
};

rec func fib $n {
	if n < 2 {
		1
	} else {
		fib (n - 2) + fib (n - 1)
	}
};

=>

let basic fib $n = (
	basic func $f fib $n {
		let basic $(fib $n) = (f) f;
		if n < 2 {
			1
		} else {
			fib (n - 2) + fib (n - 1)
		}
	};

	($f fib $n) fib $n
);

fib 5

fibMemo $n => (fibY using memo) n;

-------------------------------------------------

// OLD Parsing instructions
(($(add (4) to ($(a) as 7)) as #a #0) => add 4 to 7) ($x _ => x + 4)
// NEW SYNTAX:                 $a $#0

1. Choose a $(...) and move to its outside
2. If inside another $(...), move to its outside, and then keep leaving scopes until you find 'as'
   If not, keep leaving scopes until you find '=>'
3. Your variable is defined after this 'as' or '=>'

-------

// returns f c + a = f 456 + 123 = fu 123 nc 456 + 123
(($(f $b) as fu #($(a $f $x) as #123 $f $x) nc $b) $c => f c + a) (fu 123 nc) 456

// returns f c + n = f 456 + 122 = fu 123 nc 456 + 122
// '122' is here below syntax sugar for 'PlusOne #121'
(($(f $b) as fu #(PlusOne ($n as 122)) nc $b) $c => f c + n) (fu 123 nc) 456

// ISSUE: if 'f' <=> 'f $x', then 'f $x' <=> '(f $x) $x' <=> '((f $x) $x) $x' <=> ...

---------------------

Let f $x, $a f $b be patterns/functions

Then:
   f <=>    f $x
$a f <=> $a f $b

let f = $x => ...;
<=>
let f $x = $x => ...;

This is because there is no pattern matching before ‘as’. So doing ‘$x’ there serves no other purpose than naming the pattern / which order args come in.

Both patterns and anonymous functions can be passed around as values.

‘$x => ...’ is almost equivalent to ‘$x’.

All inputs to functions are parenthesised. They are also evaluated unless frozen.

---------------------

Number literals can be linked to types for a certain scope. This allows changing the link for different scope, a.k.a. changing the representation (between for example machine and natural numbers).

// default representation, change part
// after ‘=‘ to change representation
let __NUMBERS__ = any Nat;
let __STRINGS__ = any String;

let n  = rand any Nat;
let n2 = rand any Nat;

// TODO: Fix so that func def order doesn't matter but variable order still does

let Even = Zero|(PlusOne (PlusOne Zero))|...;
let Even = even_zero|(even_plus2 Zero);
let Even = Zero|(EvenI Zero);

// needs lazy list, could be impl using permafrost '{}' and defrost during access
let Even = lazily flatten [Zero, EvenIL Zero]; // allows for Even.0, Even.2, etc.
let any Even = Zero|(EvenI Zero); // allows for '$n as any Even'

basic func any $b {orify b};

basic func orify $list {
	list[0]|list[1]|...
};

basic func use $module {
	if module.length > 0 {
		frozenraw (
			module[0];
			use module[1..];
		)
	}

	scope
};

func even_zero {
	Zero
};

func even_plus2 $n {
	PlusOne (PlusOne n)
};

func EvenI $n {
	let next = PlusOne (PlusOne n);
	next|(EvenI next)
}

func EvenIL $n {
	let next = PlusOne (PlusOne n);
	[next, EvenI next]
}

---------------------

func any $list {
	(list[0] (ALL_ARGS_BUT_ONE list[0])) | if list length > 1 then any list[1..] else (list[0] (ALL_ARGS_BUT_ONE list[0]))
};

func $list.($field as frozen) {
	for each item in list {
		if item == frozen field {
			return field;
		}
	};

	Nothing
};

---------------------

let field = frozen (Zero $x);
let item $x = Zero $x;

let n  $x = Zero $x;
let n2 $x = Zero $x;

n $x == n2 $x

(
	let Zero $x = $x => ;

	Zero $x

	/////////

	$(Zero $x) => (
		Zero $x
	) ($x => )
)

let item = (
	func Zero _ {};

	Zero
);

let item = item;

$(item $x) => (
	$(`item $x`) => (
		...
	) (item $x)
) (
	$(Zero $x) => (
		Zero $x
	) ($x => )
)

---------------------

func use $module {
	frozenraw (
		let `module[0]` = module[0]; // using '``' to clarify the name is the evaluated module[0] rather than 'module[0]'
		if module length > 1 {
			use module[1..];
		};
	)
};

let Module = [
	f $a,
	0,
	g $x $y
];

any Module == f|0|(g _)|(g _)

let Nat = (
	func Zero _ {};
	func PlusOne ($n as Zero|(PlusOne _)) _ {};

	[Zero, PlusOne]
);

any Nat == Zero|(PlusOne Zero|(PlusOne _))

use Nat;

Zero                   == Nat.Zero
PlusOne (PlusOne Zero) == Nat.PlusOne (Nat.PlusOne Nat.Zero)

// TODO: Bring back operator defs in some way (before it was 'operator +;')
// TODO: Actually define 'let'. Apparently you forgot that and only 'let basic/pure' exists.

---------------------

func $this where ($contract as frozen any Bool) {
	if contract then this
};

(0|1|2|3 where this mod 2 == 0): 0|2

---------------------

// Something is an *object* if it's atomic or only contains properties of itself
object Player [
  $x      as any Int,
  $y      as any Int,
  $health as any Double
];

let HealthContract = frozen (
  this health > 50.0 &&
  this health < 100.0
);

// Something is a *category* if it contains objects that aren't properties of itself
let items = [
  Dirt,
  Stone,
  Wood
];

func throw ($item as any of items) from ($player as any Player fulfilling HealthContract) {...};

throw Stone   from (Player 123 456 75.0); // ok
throw Dirt    from (Player 123 456 75.0); // ok
throw Invalid from (Player 123 456 75.0); // ERROR
throw Stone   from (Player 123 456 30.0); // ERROR
throw Stone   from (Bird 123 456 75.0); // ERROR

// Maybe only use wrapper objects when there's an use for it?
// Use like Haskell constructors?
// Lists could be used for the types instead
module Nat [
	object Zero,
	object (Nat) PlusOne,

	let nats = [
		Zero,
		_ PlusOne
	],

	let Nat = any of nats
];

module Bool [
	object True,
	object False,

	let bools = [
		True,
		False
	],

	let Bool = any of bools
];

---------------------------------------
// Testing new potential syntax below

basic func any $obj {obj (ALL_ARGS_BUT_ONE obj)};

basic func any of ($list as any List) {
	// TODO
};

let basic any $list = any of $list;

// This:
category Category (
	object Object  [$a, $b, ..., $z];
	object Object2 [$a, $b, ..., $z];
	...
	object ObjectN [$a, $b, ..., $z];

	export [
		Object,
		Object2,
		...,
		ObjectN
	]
)

// Becomes:
let Category = (
	func Object  $a $b ... $z _ {};
	func Object2 $a $b ... $z _ {};
	...
	func ObjectN $a $b ... $z _ {};

	// Should the insertion of 'any' instead be handled by the 'any $list' function?
	[any Object, any Object2, ..., any ObjectN] // TODO: make list dot-accessible
);

// Unexposed use:
let obj:  any Category = Category.Object   _ _ ... _;
let obj2: any Category = Category.Object2  _ _ ... _;

// Exposed use:
expose Category;

let obj:  any Category = Object _ _ ... _;
let obj2: any Category = Object _ _ ... _;

// Example:
category Character (
	object Player [
		$health as Number
	];

	object NPC [
		$health as Number
	];

	// TODO:
	// Player and NPC share some similar properties; how to prevent code duplication?
	// Apparently Rust doesn't do anything about this; maybe it's not worth it?

	object NonExportedExperiment [
		$idk
	];

	export [Player, NPC]
);

// If 'Character' was in another file, we would also need to 'import' that file first
// TODO: Consider merging 'import' and 'expose' to Rust's 'use'
expose Character;

let player: any Character = Player 100;
let npc:    any Character = NPC 50;

player = npc; // works fine, because only restriction is that it stays a character

// Better:
let player: any Player = Player 100;
let npc:    any NPC    = NPC 50;

player = npc; // ERROR!
player = Player 80; // fine

category Bool (
	object True;
	object False;

	export all;
);

if Bool.True {
	println "always";
};

expose Bool;

if False {
	println "never";
};

False: any Bool;
True: any Bool;

Bool.False: any Bool;
Bool.True: any Bool;

// Bool is a special list where you can access items with '.'
// Kind of like JS objects
// Bool = [True, False]
any Bool == any of [Bool.True, Bool.False] == Bool.True|Bool.False

// Another example
category Shape (
  object Rectangle [
    $width,
    $height
  ];

  object Circle [
    $radius
  ];
  
  export all;
);

expose Shape; // so we don't need to type Shape.Circle and Shape.Rectangle all the time

let shape: any Shape = Circle 100; // ok
shape = Rectangle 300 150; // ok
shape = Bird 123; // ERROR

let shape2: any Circle = Circle 100; // ok
shape = Rectangle 300 150; // ERROR
shape = Circle 150; // ok

let shape3: Circle 100 = Circle 100; // ok
shape3 = Circle 150; // ERROR