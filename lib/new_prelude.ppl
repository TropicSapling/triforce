// Syntax sugar
$a                 <=> ($a as _) // 'a' can be called like 'a arg1 arg2 ...'
$(f $a $b ...)     <=> ($(f $a $b ...) as #0 #1 ...)
(x)                <=> (_ as x) // where 'x' is not '$a' ('$a b' is allowed and will become '_ as $a b')

// Requirements for *complete* functions (*basic* functions don't allow these easily)
- Attributes
- Recursion
- Types

////////////////////////////////////////////////////////////////

($(let basic $var = $val;) => scope) (($var as frozen) $val => (var => scope) val)

// Normal 'frozen' keyword only freezes until 'expr' gets used again.
// Use '{expr}' to freeze expression and make it stay frozen. Unfreeze with '{expr} _'.
let basic $({$expr as frozen} _) = $expr _ => expr;

let basic $(basic func ($pattern as frozen) $(body _);) = $pattern $(body _) => frozen (let basic $pattern = ALL_ARGS pattern => body _;);

basic func Nothing $f $x {scope};

basic func remaining args of $f {
	ALL_ARGS f length - APPLIED_ARGS f length
};

// Boxes
basic func category of ($wrapper (ALL_ARGS wrapper)) {wrapper};
basic func unbox $b {APPLIED_ARGS b};

// Bool True|False
basic func Bool True  $x _  {x};
basic func Bool False _  $y {y};

let basic $True  = Bool True;
let basic $False = Bool False;

basic func (True)   && (True)   {True};
basic func (Bool _) && (Bool _) {False};

basic func (False)  || (False)  {False};
basic func (Bool _) || (Bool _) {False};

basic func !(True)  {False};
basic func !(False) {True};

basic func $a == $a {True};
basic func _  == _  {False};
basic func $a != $b {!(a == b)};

// if_then_else
basic func if (True)    $body            {body};
basic func if (False)   _                {scope};
basic func if (Bool $b) $body else $expr {b body expr};

basic func if (True)    then $body            {body};
basic func if (False)   then _                {scope};
basic func if (Bool $b) then $body else $expr {b body expr};

// Type checking
basic func any $b {b (ALL_ARGS b)};

basic func if fulfilling (True)         $body {body};
basic func if fulfilling (frozen $cond) _     {
	if !cond {
		// continue to next function def if there is one, else panic
		continue from caller or alt prerun panic (format_err (format "Failed to fulfill condition '{}'" [stringify {cond}]))
	} else {
		panic (format_err "Contract is not a Bool")
	};
};

basic func if fulfilling (True)  $body else report _             {body};
basic func if fulfilling (False) _     else report (String $msg) {
	continue from caller or alt prerun panic (format_err (String msg))
};

// TODO: Fix so that stuff below works with new syntax

$f using $closure => if fulfilling remaining args of closure == 1 (
	f ((closure _) f)
);

memo _ => (
	$f $next $x => f (next) x
);

fibY $next $n => if n < 2 (
	1
) else next (next) (n - 2) + next (next) (n - 1);

fibMemo $n => (fibY using memo) n;

basic func @($attr as frozen) $(id as frozen) {
	ATTRIBUTE attr id
} // use '##' instead if you decide to use '@' for pointers

untyped func @(precedence below _) $($expr;) {
	scope
}

let {($expr as frozen)} _ = ($expr as frozen) => expr;

-------------------------------------------------

// Parsing instructions
(($(add (4) to ($(a) as 7)) as #a #0) => add 4 to 7) ($x _ => x + 4)

1. Choose a $(...) and move to its outside
2. If inside another $(...), move to its outside, and then keep leaving scopes until you find 'as'
   If not, keep leaving scopes until you find '=>'
3. Your variable is defined after this 'as' or '=>'